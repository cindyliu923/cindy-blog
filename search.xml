<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>新手不小心會踩到的坑：我真的複製出物件了嗎？</title>
      <link href="/2020/06/25/ruby-pass-by-reference-and-value/"/>
      <url>/2020/06/25/ruby-pass-by-reference-and-value/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，幾天前公司早上例會的時候，討論了關於 Ruby 的指標，這次的討論讓我明白原來 Ruby 是用 rvalue 來實作，是 pass by value 但如果說超過特定長度的話這個 value 會有一個在 C 語言中實做的參考，讓我想到去年我在公司的<a href="https://5xruby.tw/posts/ruby-pass-by-reference-and-value" target="_blank" rel="noopener">官網</a>也有寫過一篇關於這件事情的文章，所以決定將這篇文章也分享在我自己的部落格裡，以下是原文。</p><hr><p>大家好，今天要來跟大家說一個如果是非本科系的工程師不確定上課有沒有學過，如果是本科系的應該是上課有學過，菜鳥工程師可能會不小心踩到的坑，在開始說明之前先給大家看一段程式碼。</p><p>這是一段很簡單的 Ruby 程式碼，表示調整廣播電台頻道的類別，支援預設電台的功能，也就是說使用者在按下某個按鈕，就可以跳到喜歡的頻道(話說現在年輕人還知道電台嗎？＠＠)。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = presets</span><br><span class="line"></span><br><span class="line">    clean</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span></span></span><br><span class="line">    @presets.delete_if &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007fe7b08ff170 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "88.5"]</span></span><br></pre></td></tr></table></figure><p>大家發現了嗎？ presets 已經被我們改變了，在討論為什麼之前我們先來看看有什麼方式可以傳遞引數！</p><h2 id="傳遞引數的方式"><a href="#傳遞引數的方式" class="headerlink" title="傳遞引數的方式"></a>傳遞引數的方式</h2><ol><li><p>Pass-by-reference：丟到方法裡的引數實際上只是變數的參考(reference)，修改引數就會修改到原始的變數。</p></li><li><p>Pass-by-value：丟到方法裡的引數是變數的值(value)，修改引數不會修改到原始的變數。</p></li></ol><h2 id="Ruby-的引數是如何傳遞？"><a href="#Ruby-的引數是如何傳遞？" class="headerlink" title="Ruby 的引數是如何傳遞？"></a>Ruby 的引數是如何傳遞？</h2><p>參考<a href="https://www.ruby-lang.org/en/documentation/faq/4/" target="_blank" rel="noopener">官網的FAQ</a>：</p><p>在 Ruby 中所有的變數和常數都會指向一個參考物件，除了直接使用會噴 NameError 例外錯誤的未初始化區域變數(沒有參考)，當我們指派一個變數或初始化一個常數，表示我們設定了變數或常數指向的參考物件。</p><p>意思是指派這件事情，實際上並不會產生一個複製的新物件，例如前面範例程式碼中 <code>presets = %w(90.1 106.2 88.5)</code> 表示說 <code>presets</code> 是會指向 <code>%w(90.1 106.2 88.5)</code> 參考物件的變數。</p><p>但 <code>Fixnum</code>, <code>true</code>, <code>nil</code>, 和 <code>false</code> 是例外，他們是 <code>immediate values</code>，變數會保持本身的物件而不是另外指向一個參考物件，這些例外被指派的引數會產生這個類型的複製物件。</p><p>當方法被調用時，引數被指派為參數：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOne</span><span class="params">(n)</span></span></span><br><span class="line">  n += <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">p addOne(a) <span class="comment"># -&gt; 2</span></span><br><span class="line">p a         <span class="comment"># -&gt; 1</span></span><br></pre></td></tr></table></figure><p>當傳遞的是物件的參考時，一個方法是有可能改變傳進來的可變物件(mutable object)：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downer</span><span class="params">(string)</span></span></span><br><span class="line">  string.downcase!</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p a = <span class="string">"HELLO"</span> <span class="comment"># -&gt; "HELLO"</span></span><br><span class="line">p downer(a)   <span class="comment"># -&gt; "hello"</span></span><br><span class="line">p a           <span class="comment"># -&gt; "hello"</span></span><br></pre></td></tr></table></figure><h3 id="小結："><a href="#小結：" class="headerlink" title="小結："></a>小結：</h3><ul><li>Ruby 傳遞引數的方法並沒有相當於其他語言的 pass-by-reference。</li><li>Ruby 是 pass-by-value，但是 values 是 references，Pass by reference value 可能是相對準確的說法。</li></ul><hr><p>回頭看看上面的 code，把 <code>object_id</code> 印出來觀察，presets 改變的原因是因為傳進方法的是可變物件的參考(相同 <code>object_id</code>)，當我們直接改變物件就直接改到了原來的物件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = presets</span><br><span class="line"></span><br><span class="line">    clean</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span></span></span><br><span class="line">    @presets.delete_if &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">    p @presets.object_id <span class="comment"># -&gt; 70140344834080</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p presets.object_id <span class="comment"># -&gt; 70140344834080</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007fe7b08ff170 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "88.5"]</span></span><br></pre></td></tr></table></figure><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>上面的範例，看起來可以改成這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = clean(presets)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(presets)</span></span></span><br><span class="line">    presets.reject &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007f9adfaa2b80 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br></pre></td></tr></table></figure><p>因為 reject 會以傳回一個新的陣列代替更改接收端(presets)，故原本的物件並不會被我們修改到，但這並不一定是個好方法，如果我們不需要在初始化的階段就更改 presets，或是其他實體的方法才需要更改 presets，還是有可能會遇到麻煩。</p><p><strong>所以其實我們真正想要的是，可以用複製物件來代替指向原本物件的參考。</strong></p><h2 id="Ruby-複製物件的方法"><a href="#Ruby-複製物件的方法" class="headerlink" title="Ruby 複製物件的方法"></a>Ruby 複製物件的方法</h2><p>Ruby 有兩種複製物件的方法：<code>dup</code> 和 <code>clone</code>，雖然兩者都會根據接收端建立新物件，但 <code>clone</code> 會保存原始物件的 2 項額外功能，<code>dup</code> 則不會。</p><h3 id="clone-不同於-dup-的-2-項額外功能："><a href="#clone-不同於-dup-的-2-項額外功能：" class="headerlink" title="clone 不同於 dup 的 2 項額外功能："></a><code>clone</code> 不同於 <code>dup</code> 的 2 項額外功能：</h3><ol><li><p><code>clone</code> 會顧及接收端的凍結狀態(frozen status)，如果原始物件已經凍結，那副本也會是凍結的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">object = Object.new</span><br><span class="line">object.freeze</span><br><span class="line">p object.frozen? <span class="comment"># -&gt; true</span></span><br><span class="line">dup_object = object.dup</span><br><span class="line">p dup_object.frozen? <span class="comment"># -&gt; false</span></span><br><span class="line">clone_object = object.clone</span><br><span class="line">p clone_object.frozen? <span class="comment"># -&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p>如果接收端有單例方法，<code>clone</code> 會複製單例類別(singleton class)。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object = Object.new</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">wow</span>;</span> <span class="symbol">:wow</span> <span class="keyword">end</span></span><br><span class="line">p object.singleton_methods <span class="comment"># -&gt; [:wow]</span></span><br><span class="line">p object.wow <span class="comment"># -&gt; :wow</span></span><br><span class="line">clone_object = object.clone</span><br><span class="line">dup_object = object.dup</span><br><span class="line">p clone_object.wow <span class="comment"># -&gt; :wow</span></span><br><span class="line">p dup_object.wow <span class="comment"># -&gt; undefined method `wow' for #&lt;Object:0x00007f7effa8af40&gt; (NoMethodError)</span></span><br></pre></td></tr></table></figure></li></ol><p>所以當我們想修改物件的時候，大部分會選則用 <code>dup</code> 而不是 <code>clone</code>，因為凍結的物件無法修改或解凍，所以 <code>clone</code> 可能會回傳無法修改的物件。</p><h2 id="修改程式碼"><a href="#修改程式碼" class="headerlink" title="修改程式碼"></a>修改程式碼</h2><p>所以我們現在將程式碼改成這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = presets.dup</span><br><span class="line"></span><br><span class="line">    clean</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span></span></span><br><span class="line">    @presets.delete_if &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007fe7b08ff170 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br></pre></td></tr></table></figure><p>恭喜！這樣就解決了我們一開始更改到原始物件的問題了！</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>雖然我們已經解決問題了，但要留意 <code>dup</code> 和 <code>clone</code> 只會產生淺層複製(shallow copy)的物件，意思是對於 <code>Array</code> 這類的集合物件，雖然複製了容器，但並未複製容器內的元素，我們可以在不影響原始物件的情況下加入或移除元素，但是如果我們試圖要修改 <code>Array</code> 裡的元素，就會修改到原始元素，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="string">"Polar"</span>]</span><br><span class="line">p dup_array = array.dup &lt;&lt; <span class="string">"Bear"</span> <span class="comment"># -&gt; ["Polar","Bear"]</span></span><br><span class="line">p dup_array.each &#123; <span class="params">|element|</span> element.sub!(<span class="string">"lar"</span>, <span class="string">"oh"</span>) &#125; <span class="comment"># -&gt; ["Pooh", "Bear"]</span></span><br><span class="line">p array <span class="comment"># -&gt; ["Pooh"]</span></span><br></pre></td></tr></table></figure><p>可以看到我們還是修改到原始物件的元素了，編寫自己的類別的時候我們可以複寫 <code>initialize_copy</code> 這個方法來控制複製過逞的深度，如果需要使用既有類別深層副本的物件，就必須自行處理。</p><p>另外有一個方法是可以使用 <a href="https://ruby-doc.org/docs/ruby-doc-bundle/ProgrammingRuby/book/ref_m_marshal.html" target="_blank" rel="noopener">Marshal</a> 類別來序列化，然後再對集合及其元素進行序列化還原：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="string">"Polar"</span>]</span><br><span class="line">p dup_array = Marshal.load(Marshal.dump(array)) &lt;&lt; <span class="string">"Bear"</span> <span class="comment"># -&gt; ["Polar","Bear"]</span></span><br><span class="line">p dup_array.each &#123; <span class="params">|element|</span> element.sub!(<span class="string">"lar"</span>, <span class="string">"oh"</span>) &#125; <span class="comment"># -&gt; ["Pooh", "Bear"]</span></span><br><span class="line">p array <span class="comment"># -&gt; ["Polar"]</span></span><br></pre></td></tr></table></figure><p>使用 <code>Marshal</code> 會有相當的限制，除了時間，他要對物件序列化並還原序列化，還必須考慮記憶體的需求數量。複製的物件將會佔用它自己的記憶體空間，如此一來使得 <code>Marshal::dump</code> 建立序列化位元組資料流，因此假如載入大型物件會使得程式大幅增加記憶體需求。</p><p>另一個問題是 <code>Marshal</code> 並非可以對所有的物件作序列化，例如 IO 類別的實體、單例物件(singleton objects)等，會引發 TypeError 的例外。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>大部分的情況我們使用 <code>dup</code> 就可以解決想要複製物件的問題了，但如果我們可以了解這些限制能讓我們將來在需要做深層副本的時候遠離麻煩。</li><li>Ruby 表現得像為不可變物件傳遞值(pass-by-value)，為可變物件傳遞參考(pass-by-reference)。</li><li><code>dup</code> 和 <code>clone</code> 只會建立淺層副本。</li><li>大多數物件來說，<code>Marshal</code> 能在需要時用來建立深層副本。</li></ul><h3 id="參考：-Effective-Ruby"><a href="#參考：-Effective-Ruby" class="headerlink" title="參考： Effective Ruby"></a>參考： <a href="https://www.effectiveruby.com" target="_blank" rel="noopener">Effective Ruby</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> pass-by-reference </tag>
            
            <tag> pass-by-value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code - 有意義的命名</title>
      <link href="/2020/06/13/clean-code-naming/"/>
      <url>/2020/06/13/clean-code-naming/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，相信看過 <a href="/2020/06/06/clean-code">Clean Code - 無瑕的程式碼</a> 這篇文章的朋友們已經知道什麼是 Clean Code 了，接下來就會需要探討究竟要如何實現？</p><p><a href="https://www.tenlong.com.tw/products/9789862017050?list_name=e-106" target="_blank" rel="noopener">無瑕的程式碼－敏捷軟體開發技巧守則 (Clean Code: A Handbook of Agile Software Craftsmanship)</a> 第二章有意義的命名，就像我之前說的最簡單最困難，相信已經身為工程師的大家們，寫個 method 是一件相當容易的事情，但寫個好的 method 名稱，似乎就不那麼容易了，本篇文章會針對書中提到的幾個重點做說明並用 Ruby 來做舉例。</p><h2 id="讓名稱代表意圖—-使之名符其實"><a href="#讓名稱代表意圖—-使之名符其實" class="headerlink" title="讓名稱代表意圖—-使之名符其實"></a>讓名稱代表意圖—-使之名符其實</h2><p>變數、方法或類別的名稱，它應該要告訴我們，它為什麼會在這出現、它要做什麼用、該如何使用它。如果一個名稱需要註解的輔助，那麼這個名稱就不具備展現意圖的能力。</p><p>當我們試著說出下面這段程式碼的目的，竟然是一件相當困難的事情，會出現我都看得懂，但不知道他要幹嘛的感覺。我想當我們閱讀程式碼出現這樣的想法的時候，其實就表示說這可能是一段命名不好的程式碼。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_them</span></span></span><br><span class="line">  list1 = []</span><br><span class="line">  the_list.each <span class="keyword">do</span> <span class="params">|x|</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="number">0</span>] == <span class="number">4</span></span><br><span class="line">      list1.push(x)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  list1</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>雖然程式碼很短很簡單，但問題不在於程式碼的簡易度，而是在於程式碼的<strong>隱含性(implicity)</strong>，即程式碼的上下文資訊(context)未能由程式本身明確地展現出來的程度，這邊突然想起<a href="https://www.youtube.com/watch?v=pFDRvya23us" target="_blank" rel="noopener">知識的詛咒</a>，就好像撰寫程式碼的工程師心裡知道一切，但是並沒有把心裡知道的寫出來。</p><p>我們把上面那段程式碼做一些修改：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  flagged_cells = []</span><br><span class="line">  game_board.each <span class="keyword">do</span> <span class="params">|cell|</span></span><br><span class="line">    <span class="keyword">if</span> cell[STATUS_VALUE] == FLAGGED</span><br><span class="line">      flagged_cells.push(cell)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  flagged_cells</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊只是將程式碼的命名做修改，看起來就不太一樣了，比前一個例子清楚一些，那我們再做一些修改：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  flagged_cells = []</span><br><span class="line">  game_board.each <span class="keyword">do</span> <span class="params">|cell|</span></span><br><span class="line">    <span class="keyword">if</span> cell.flagged?</span><br><span class="line">      flagged_cells.push(cell)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  flagged_cells</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  flagged_cells = []</span><br><span class="line">  game_board.each <span class="keyword">do</span> <span class="params">|cell|</span></span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">unless</span> cell.flagged?</span><br><span class="line"></span><br><span class="line">    flagged_cells.push(cell)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  flagged_cells</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>大家發現了嗎？這邊看起來就是有一個遊戲版，然後我們用這個方法取得在遊戲版上被標記的格子。我們只是做重新命名，就看出程式碼的目的了！</p><p>最後還可以改成下面這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  game_board.select(&amp;<span class="symbol">:flagged?</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="產生有意義的區別"><a href="#產生有意義的區別" class="headerlink" title="產生有意義的區別"></a>產生有意義的區別</h2><p>如果說我們發現程式碼中出現兩個名稱是看不出區別的，那就不應該同時用這兩個名稱，例如 <code>Info</code> 和 <code>Data</code> 是不可區分的無意義字詞，在沒有特別約定的情況下，<code>money_account</code> 和 <code>money</code>、<code>customer_info</code> 和 <code>customer</code>、<code>account_data</code> 和 <code>account</code>、<code>the_message</code> 和 <code>message</code> 都是沒有區別的！</p><h2 id="使用能唸出來的名稱"><a href="#使用能唸出來的名稱" class="headerlink" title="使用能唸出來的名稱"></a>使用能唸出來的名稱</h2><p>大家可以想像一下，如果工程師們在討論一個念不出來的方法，究竟要怎麼討論？</p><h2 id="使用可被搜尋的名稱"><a href="#使用可被搜尋的名稱" class="headerlink" title="使用可被搜尋的名稱"></a>使用可被搜尋的名稱</h2><p>假設某個數字在程式碼中有特別的意義，<code>WORK_DAY_PER_WEEK = 5</code>，像這樣的寫法會比直接在程式碼中用 5 去做計算來的好，因為如果我們用 <code>WORK_DAY_PER_WEEK</code> 去搜尋整個專案，絕對會比用 5 搜尋來得好！</p><h2 id="類別的命名"><a href="#類別的命名" class="headerlink" title="類別的命名"></a>類別的命名</h2><p>類別和物件應該使用名詞或名詞片語來命名，類別的名稱也不應該是動詞。大家可以參考 <a href="https://railsbook.tw/chapters/08-ruby-basic-4.html" target="_blank" rel="noopener">類別（Class）與模組（Module）</a> 這篇文章，類別其實就像是一個模子，當我們 new 出一個實體（Instance），表示為具有類別上狀態與行為的物件，這就是個名詞無誤。</p><h2 id="方法的命名"><a href="#方法的命名" class="headerlink" title="方法的命名"></a>方法的命名</h2><p>方法應該使用動詞或動詞片語來命名。方法就是個行為，行為是動作，所以應該要是動詞。</p><h2 id="每個概念使用一種字詞"><a href="#每個概念使用一種字詞" class="headerlink" title="每個概念使用一種字詞"></a>每個概念使用一種字詞</h2><p>例如 <code>fetch</code>、<code>retrieve</code>、<code>get</code> 這三個都是取得的意思，應該要統一用一種。</p><h2 id="別說雙關語"><a href="#別說雙關語" class="headerlink" title="別說雙關語"></a>別說雙關語</h2><p>避免使用同一個字詞來表示兩種不同的目的，例如專案中已經大量使用 <code>add</code> 表示相加或相連兩個現有的值，然後形成新的值，而我們今天要撰寫一個新的方法是會將單一參數放入一個集合容器中，那我們可以取名為 add 嗎？如果我們用 <code>add</code> 了是不是就表示整個專案裡的 <code>add</code> 會有兩種意思？這就是一種雙關語的表現，所以我們應該取名為 <code>insert</code> 或 <code>append</code> 之類的。</p><h2 id="使用解決方案領域的命名"><a href="#使用解決方案領域的命名" class="headerlink" title="使用解決方案領域的命名"></a>使用解決方案領域的命名</h2><p>解決方案領域其實就是工程師領域的意思，因為在寫跟在看程式碼的人都是工程師，所以如果可以應該盡量使用工程師一看就懂的字詞，例如 <code>JobQueue</code> 之類的。</p><h2 id="使用問題領域的命名"><a href="#使用問題領域的命名" class="headerlink" title="使用問題領域的命名"></a>使用問題領域的命名</h2><p>問題領域就是這個專案在做什麼領域的事情，例如如果是電商網站那就是電商的領域，如果是遊戲網站就會是遊戲的領域。如果沒有工程師熟悉的字詞可以使用的時候，或某段程式碼與問題領域的概念更接近，我們就會使用該問題領域的術語來命名。</p><h2 id="添加有意義的上下文資訊-Context"><a href="#添加有意義的上下文資訊-Context" class="headerlink" title="添加有意義的上下文資訊 (Context)"></a>添加有意義的上下文資訊 (Context)</h2><p>例如有一個變數 <code>state</code>，如果單看這個變數會看不出這是什麼，如果改成 <code>addr_state</code> 至少可以知道這是地址的州，更好的做法是將零碎的變數給予更大的類別 Address。但記得如果小的名稱就能清楚表達的話，就不需要加入其他 context。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我想從這章節可以學到很多實際上的做法，也會讓我省思過去是不是寫了不好的命名，也確實遇過書中寫到面對不好命名的窘境，雖然說程式碼是要讓電腦去執行的，但其實也是要讓人類去閱讀的，因為撰寫程式碼的也是人類，所以能夠表達清楚，是讓後面接手的人可以更好維護的方法之一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Coding </tag>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby 物件導向設計實踐－敏捷入門</title>
      <link href="/2020/06/09/Practical-Object-Oriented-Design-in-Ruby/"/>
      <url>/2020/06/09/Practical-Object-Oriented-Design-in-Ruby/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近在整理 medium 舊的文章 <a href="https://medium.com/@cindyliu923/ruby-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%AF%A6%E8%B8%90%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-e0a357e3fd17" target="_blank" rel="noopener"><strong>Ruby 物件導向設計實踐讀書筆記</strong></a>，想把這篇也放在這裡，但覺得需要重新整理一下，<del>就跟過了一陣子再看我寫的程式碼一樣</del>，所以這篇文章就此誕生？</p><p>首先跟大家說一下，<a href="https://www.tenlong.com.tw/products/9789864340101" target="_blank" rel="noopener">Ruby 物件導向設計實踐－敏捷入門 (Practical Object-Oriented Design in Ruby: An Agile Primer)</a> 是一本書，作者是 <a href="https://www.sandimetz.com" target="_blank" rel="noopener">Sandi Metz</a> 致力推行物件導向程式設計的實踐，出了兩本書 Practical Object-Oriented Design (POODR) 和 <a href="https://www.sandimetz.com/99bottles" target="_blank" rel="noopener">99 Bottles of OOP</a>，都是關於物件導向設計要如何實踐，而且最近發現 Sandi Metz 有很多場精彩的演講，大家可以去看看：</p><ul><li><a href="https://www.youtube.com/watch?v=v-2yFMzxqwU" target="_blank" rel="noopener">GORUCO 2009 - SOLID Object-Oriented Design by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=8bZh5LMaSmE" target="_blank" rel="noopener">RailsConf 2014 - All the Little Things by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=OMPfEXIlTVE" target="_blank" rel="noopener">RailsConf 2015 - Nothing is Something</a></li><li><a href="https://www.youtube.com/watch?v=PJjHfa5yxlU" target="_blank" rel="noopener">RailsConf 2016 - Get a Whiff of This by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=mpA2F1In41w" target="_blank" rel="noopener">hafentalks #7 - Sandi Metz: “Go Ahead, Make a Mess”</a></li></ul><p><strong>接下來是我在閱讀這本書每一章節的筆記，我另外在下面用註解的方式針對我的筆記做說明</strong></p><blockquote><p>參考程式碼如果是 A 這種沒意義的命名請不要認真覺得要這樣寫唷，只是懶得想例子而已，記得要做有意義的命名。</p></blockquote><h2 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h2><ul><li><a href="#物件導向的設計">物件導向的設計</a></li><li><a href="#設計具有單一職責的類別">設計具有單一職責的類別</a></li><li><a href="#管理依賴關係">管理依賴關係</a></li><li><a href="#建立靈活的介面">建立靈活的介面</a></li><li><a href="#使用鴨子類型技巧降低成本">使用鴨子類型技巧降低成本</a></li><li><a href="#藉由繼承取得行為">藉由繼承取得行為</a></li><li><a href="#使用模組共用角色行為">使用模組共用角色行為</a></li><li><a href="#組合物件">組合物件</a></li><li><a href="#設計節省成本的測試">設計節省成本的測試</a></li></ul><h2 id="物件導向的設計"><a href="#物件導向的設計" class="headerlink" title="物件導向的設計"></a>物件導向的設計</h2><ul><li><p>物件導向設計與依賴關係管理相關</p><ul><li>不受管理的依賴關係很容易造成嚴重破壞，因為物件之間彼此了解太多<blockquote><p>依賴關係其實就是如果某個物件的修改會影響到另一個物件，我們就可以說這兩個物件具有依賴關係</p></blockquote></li></ul></li><li><p>設計的目的是使你日後仍然可以繼續設計</p></li><li><p>設計原則</p><ul><li><p>SOLID</p><ul><li><p>單一職責(Single Responsibility Principle, SRB)</p><blockquote><p>簡單說就是一個物件只做一件事情</p></blockquote></li><li><p>開閉原則(Open-Closed Principle, OCP)</p><blockquote><p>在設計已經完整的前提下只能增加程式碼，不能改既有的程式碼</p></blockquote></li><li><p>里氏代替原則(Liskov Substitution Principle, LSP)</p><blockquote><p>若是使用繼承，子類別實作的行為必須要與父類別或是介面所定義的行為一致，並且子類別要能夠完全取代掉父類別</p></blockquote></li><li><p>介面隔離原則(Interface Segregation Principle, ISP)</p><blockquote><p>No client should be forced to depend on methods it does not use.</p></blockquote></li><li><p>依賴倒置原則(Dependency Inversion Principle, DIP)</p><blockquote><p>簡單講是物件之間的依賴關係的處理，可參考<a href="https://notfalse.net/1/dip" target="_blank" rel="noopener">這篇文章</a>，雖然範例不是 Ruby，但我覺得說明的蠻有趣的，如果說看完文章想轉成 Ruby 的話最後結果類似下面這段程式碼，其中 <code>stuffer</code> 是抽象介面，即實際上並不存在 <code>stuffer</code> 的類別</p></blockquote></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(stuffer)</span></span></span><br><span class="line">    stuffer.new.stuff</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stuff</span></span></span><br><span class="line">    p <span class="string">'咔拉雞腿滿福堡 好棒棒'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spaghetti</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stuff</span></span></span><br><span class="line">    p <span class="string">'大蒜辣椒麵 :D'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">People.new.eat(Hamburger)</span><br><span class="line">People.new.eat(Spaghetti)</span><br></pre></td></tr></table></figure></li><li><p>Don’t Repeat Yourself, DRY</p></li><li><p>Law of Demeter, LoD</p></li></ul></li><li><p>若未進行設計 =&gt; 我可以增加這項功能，但這會把所有東西破壞。</p></li></ul><h2 id="設計具有單一職責的類別"><a href="#設計具有單一職責的類別" class="headerlink" title="設計具有單一職責的類別"></a>設計具有單一職責的類別</h2><ul><li>程式碼應具備的特點(TRUE)<ul><li>透明性(Transparent)-程式碼的修改結果要顯而易見</li><li>合理性(Reasonable)-修改的成本要跟修改後的效益成正比</li><li>可用性(Usable)-既有程式碼在任何時候都要保持可用</li><li>典範性(Examplary)-程式碼本身鼓勵為延續這些特點的修改</li></ul></li><li>判斷方法<ul><li>嘗試用一句話描述類別(Class)，若描述中出現<strong>和</strong>、<strong>或</strong>表示不只做一件事情</li><li>高聚合-這個類別所做的所有事情都與其目標非常相關</li></ul></li><li>依賴<strong>行為</strong>而非資料<blockquote><p>資料庫的相關書籍也有提到說應用程式跟資料應該要分離，在寫程式的時候不應該依賴資料內容才對，否則會有應用程式與資料黏在一起的感覺啊，會進入越來越難寫的窘境</p></blockquote></li><li>只負責單一事物的類別能夠將事物與應用程式的其他部分有所<strong>隔離</strong></li></ul><h2 id="管理依賴關係"><a href="#管理依賴關係" class="headerlink" title="管理依賴關係"></a>管理依賴關係</h2><ul><li>低耦合</li><li>依賴像膠水，類別和接觸到他的事物黏在一起，存在幾滴膠水是有必要的，但如果膠水太多，應用程式會凝結成堅固的一塊</li><li>依賴注入(dependency injection)<blockquote><p>用這樣的方式其實就表示說當 A 和 B 必須具有依賴關係的時候，寧願讓依賴是 B 從外面丟進去 A 裡面，也不要是包在 A 裡面不容易察覺的地方</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @y = y</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * y.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># B 從外面丟進去 A 裡面</span></span><br><span class="line">A.new(x, B.new(...))</span><br></pre></td></tr></table></figure></li><li>隔離依賴<ul><li>隔離實例建立(當無法使用<strong>依賴注入</strong>時)<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一種方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b</span></span></span><br><span class="line">    @b <span class="params">||</span>= B.new(...)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 第二種方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @b <span class="params">||</span>= B.new(...)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * @b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>隔離外部訊息<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 將外部訊息 b_method 隔離出來(似乎可以用委派)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b_method</span></span></span><br><span class="line">    b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>移除參數順序依賴<ul><li>使用 Hash<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span>, <span class="symbol">:z</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">    @x = args[<span class="symbol">:x</span>]</span><br><span class="line">    @y = args[<span class="symbol">:y</span>]</span><br><span class="line">    @z = args[<span class="symbol">:z</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>明確定義預設值<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">  @x = args[<span class="symbol">:x</span>] <span class="params">||</span> <span class="number">5</span></span><br><span class="line">  @y = args[<span class="symbol">:y</span>] <span class="params">||</span> <span class="number">10</span></span><br><span class="line">  <span class="comment"># 如果是 boolean 下面這樣寫會有問題，全部都變成 true</span></span><br><span class="line">  @z = args[<span class="symbol">:z</span>] <span class="params">||</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 可以改使用 fetch 來寫</span></span><br><span class="line">  @z = args.fetch(<span class="symbol">:z</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 merge</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">  args = defaults.merge(args)</span><br><span class="line">  @x = args[<span class="symbol">:x</span>]</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaults</span></span></span><br><span class="line">  &#123;<span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>隔離多重參數初始化操作<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 當 A 是外部介面的一部分時</span></span><br><span class="line"><span class="comment"># 例如某個框架的東西，對我來說是不能修改的部分</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">SomeFramework</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span>, <span class="symbol">:z</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y, z)</span></span></span><br><span class="line">      @x = x</span><br><span class="line">      @y = y</span><br><span class="line">      @z = z</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將外部介面包裝起來</span></span><br><span class="line"><span class="comment"># 為某個特定類別建立實例，可以稱之為 factory，</span></span><br><span class="line"><span class="comment"># 當被迫無法修改外部介面時可以使用的技巧</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">AWrapper</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">a</span><span class="params">(args)</span></span></span><br><span class="line">    SomeFramework::A.new(args[<span class="symbol">:x</span>], args[<span class="symbol">:y</span>], arg[<span class="symbol">:z</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>選擇依賴方向<ul><li>告訴類別他們要依賴那些變化少於他們自身的事物<ul><li>有些類別更容易發生變化</li><li>具體類別比抽象類別更容易發生變化</li><li>修改具有許多依賴關係的類別會造成廣泛的影響<blockquote><p>這邊可以參考上面提到的 SOLID 的 <strong>依賴倒置原則(Dependency Inversion Principle, DIP)</strong></p></blockquote></li></ul></li></ul></li></ul><h2 id="建立靈活的介面"><a href="#建立靈活的介面" class="headerlink" title="建立靈活的介面"></a>建立靈活的介面</h2><ul><li>定義介面<ul><li>公共介面<ul><li>顯露出主要職責</li><li>期望被其他物件呼叫</li><li>不會隨便改變</li><li>其他物件可以放心依賴它</li><li>在測試裡被詳盡記錄</li></ul></li><li>私有介面<ul><li>要處理實作細節</li><li>不希望被傳送到其它物件</li><li>可因任何原因變化</li><li>其他物件不能放心依賴它</li><li>可能不會在測試裡被引用</li></ul></li></ul></li><li>關鍵字(Ruby 裡的方法)<ul><li>public</li><li>protected</li><li>private</li><li>可參考資料：<a href="https://kaochenlong.com/2011/07/26/public-protected-and-private-method-in-ruby" target="_blank" rel="noopener">Public, Protected and Private Method in Ruby</a></li></ul></li><li><strong>詢問傳送方想要什麼</strong>而非<strong>告訴接收者如何表現</strong><ul><li>表示物件之間彼此信任</li></ul></li><li>Law of Demeter, LoD<ul><li>對物件之間的傳遞進行限制：禁止將一則訊息藉由第二個不同的物件轉發給第三個物件，即<strong>只能與你的鄰近對話</strong>或<strong>只能使用一個小圓點</strong></li><li>小心使用委派(delegate) - Ruby 的 <code>delegate.rb</code>、<code>forwardable.rb</code>，Rails 的 <code>delegate</code> 方法</li></ul></li></ul><h2 id="使用鴨子類型技巧降低成本"><a href="#使用鴨子類型技巧降低成本" class="headerlink" title="使用鴨子類型技巧降低成本"></a>使用鴨子類型技巧降低成本</h2><ul><li>鴨子類型(duck typing)<ul><li>多態性(polymorphism):許多不同物件回應相同訊息的能力，duck typing 是實作多態性的方法之一<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(preparers)</span></span></span><br><span class="line">    preparers.each <span class="keyword">do</span> <span class="params">|preparer|</span></span><br><span class="line">      preparer.prepare_something(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 特定的 type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare_something</span><span class="params">(a)</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 特定的 type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare_something</span><span class="params">(a)</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="藉由繼承取得行為"><a href="#藉由繼承取得行為" class="headerlink" title="藉由繼承取得行為"></a>藉由繼承取得行為</h2><ul><li>classical inheritance<ul><li>繼承的核心是一種用於實作<strong>訊息自動委派</strong>的機制</li></ul></li><li>如果程式碼中的傳送者可以說話，如果說出：<strong>我知道你是誰，因為我知道你會做什麼</strong>，這項知識是一種會增加修改成本的依賴關係</li><li>建立抽象父類別<blockquote><p>這裡會寫說抽象是因為實際上我們不會去 new 一個父類別出來使用，而是會針對不同的情況 new 出不一樣的子類別，所以我們說是將行為提升至抽象，而子類別我們就會說是具體的</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildernB</span> &lt; Father</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>提升抽象行為<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:specific</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">    <span class="keyword">super</span>(args) <span class="comment"># 子類別現在"必須"傳送 super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>從具體分離出抽象<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    <span class="comment"># 本來兩個子類別方法中共用的參數</span></span><br><span class="line">    <span class="comment"># 從具體的子類別中分離出來</span></span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>]</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用範本方法模式(<strong>template method pattern</strong>)<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>] <span class="params">||</span> default_arg1</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>] <span class="params">||</span> default_arg2</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 共同的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg1</span></span></span><br><span class="line">    <span class="string">'10-arg1'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    <span class="string">'23'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildernB</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    <span class="string">'2.1'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>實作所有的範本方法(<strong>template method</strong>)<ul><li>將子類別的方法寫進父類別中，即使是不做事也要實作該方法，讓工程師知道繼承這個類別時一定要實作哪些方法<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 只要在當下稍微用心一點，</span></span><br><span class="line">  <span class="comment"># 建立出在失敗時帶有合理錯誤訊息的程式碼，</span></span><br><span class="line">  <span class="comment"># 就能夠得到永久性的益處</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    raise NotImplementedError,</span><br><span class="line">      <span class="string">"This <span class="subst">#&#123;<span class="keyword">self</span><span class="class">.<span class="keyword">class</span>&#125; <span class="title">cannot</span> <span class="title">respond</span> <span class="title">to</span>:"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">  <span class="keyword">end</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="keyword">end</span></span></span></span><br></pre></td></tr></table></figure></li></ul></li><li>父子間的耦合管理<ul><li>緊密耦合的類別會黏再一起，並且可能無法單獨修改<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:specific</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">    <span class="keyword">super</span>(args) <span class="comment"># 子類別現在"必須"傳送 super</span></span><br><span class="line">    <span class="comment"># 這個 super 造成父子之間的耦合</span></span><br><span class="line">    <span class="comment"># 強迫子類別知道如何與其抽象父類別互動</span></span><br><span class="line">    <span class="comment"># 將演算法的知識下放到子類別裡</span></span><br><span class="line">    <span class="comment"># 導致程式碼在多個子類別中重複</span></span><br><span class="line">    <span class="comment"># 並且需要所有子類別在完全相同的地方傳送 super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 父類別有一樣的方法</span></span><br><span class="line">  <span class="comment"># 同上形成耦合</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">other</span></span></span><br><span class="line">    <span class="keyword">super</span>.merge(hash)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用鉤子(hook)訊息解耦<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>] <span class="params">||</span> default_arg1</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>] <span class="params">||</span> default_arg2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提供子類別使用</span></span><br><span class="line">    post_initialize(args)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 實作方法，但不做事</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別可選擇性覆蓋這個方法</span></span><br><span class="line">  <span class="comment"># 子類別不再控制初始化</span></span><br><span class="line">  <span class="comment"># 將特殊化提供給更大型的抽象演算法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">other</span></span></span><br><span class="line">    &#123;<span class="symbol">a:</span> <span class="string">'a'</span>, <span class="symbol">b:</span> <span class="string">'b'</span>&#125;.merge(local_other)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用於子類別覆蓋的 hook</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">local_other</span></span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 不用強迫子類別知道父類別實作了 other 的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">local_other</span></span></span><br><span class="line">    &#123;<span class="symbol">c:</span> <span class="string">'c'</span>&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用 hook 方法可以讓繼承者不用強迫傳送 super，並且還能提供特殊化內容</li></ul></li></ul><h2 id="使用模組共用角色行為"><a href="#使用模組共用角色行為" class="headerlink" title="使用模組共用角色行為"></a>使用模組共用角色行為</h2><ul><li>理解物件所扮演的角色，找出隱藏角色，建立程式碼，以便在多個扮演者之間共用行為，同時要最小化其中所產生的依賴關係</li><li>ruby 的模組(module)<ul><li>撰寫技巧與繼承相似，但模組更在乎的是<strong>像什麼</strong>，而繼承是<strong>是什麼</strong><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/skmetz/poodr2/blob/master/7_10.rb</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Schedulable</span></span></span><br><span class="line">  <span class="keyword">attr_writer</span> <span class="symbol">:schedule</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span></span><br><span class="line">    @schedule <span class="params">||</span>= Schedule.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedulable?</span><span class="params">(starting, ending)</span></span></span><br><span class="line">    !scheduled?(starting - lead_days, ending)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">scheduled?</span><span class="params">(starting, ending)</span></span></span><br><span class="line">    schedule.scheduled?(<span class="keyword">self</span>, starting, ending)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 包含者可以加以覆蓋</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lead_days</span></span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>找尋方法的順序<ul><li>單例類別(Singleton class 只在這個 instance 所定義的方法)-&gt;模組(extend instance 的 module 所定義的方法)-&gt;類別-&gt;類別包含的模組-&gt;父類別-&gt;父類別包含的模組-&gt;Object …</li><li><a href="https://www.spreered.com/ruby-object-model-1" target="_blank" rel="noopener">Ruby 的繼承鍊 (1) - 如何實踐物件導向</a></li><li><a href="https://www.spreered.com/ruby-object-model-include-prepend-extend" target="_blank" rel="noopener">Ruby 的繼承鍊 (2) - Module 的 include、prepend 和 extend</a></li></ul></li><li><strong>抽象父類別裡的所有程式碼都應該適用於每個繼承他的類別</strong>，父類別不應該包含只適用於部分(而非全部)子類別的程式碼，這項限制也同樣應用在模組上：<strong>模組裡的程式碼必須也能夠一併適用於包含他的所有事物</strong></li><li>里氏代替原則(Liskov Substitution Principle, LSP)：子類型必須能夠代替他們的父類型</li></ul><h2 id="組合物件"><a href="#組合物件" class="headerlink" title="組合物件"></a>組合物件</h2><ul><li>composition<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'forwardable'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parts</span></span></span><br><span class="line">  extend Forwardable</span><br><span class="line">  def_delegators <span class="symbol">:</span>@parts, <span class="symbol">:size</span>, <span class="symbol">:each</span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(parts)</span></span></span><br><span class="line">    @parts = parts</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">    select &#123;<span class="params">|part|</span> part.needs_spare&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Struct 接收的是按順序排列的初始化參數，</span></span><br><span class="line"><span class="comment"># 而 OpenStruct 在初始化時則是接收一個 Hash</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'ostruct'</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">PartsFactory</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">build</span><span class="params">(config, parts_class = Parts)</span></span></span><br><span class="line">    parts_class.new(</span><br><span class="line">      config.collect &#123;<span class="params">|part_config|</span></span><br><span class="line">        create_part(part_config)&#125;)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">create_part</span><span class="params">(part_config)</span></span></span><br><span class="line">    OpenStruct.new(</span><br><span class="line">      <span class="symbol">name:</span>        part_config[<span class="number">0</span>],</span><br><span class="line">      <span class="symbol">description:</span> part_config[<span class="number">1</span>],</span><br><span class="line">      <span class="symbol">needs_spare:</span> part_config.fetch(<span class="number">2</span>, <span class="literal">true</span>))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/skmetz/poodr/blob/master/chapter_8.rb#L422</span></span><br></pre></td></tr></table></figure></li><li>組合允許物件之間的結構獨立性，其代價是需要明確進行訊息委派</li><li>如果問題可以使用組合技巧解決，應該盡可能使用組合，如果無法明確保證繼承是一種更好的解決方案，要用組合，因為組合的依賴關係比繼承少許多</li><li>選擇關係：<ul><li>將繼承用於<strong>是什麼</strong>的關係</li><li>將 duck typing 用於<strong>表現得像什麼</strong>的關係<ul><li>思考角色最明確的方法是從外部，以角色扮演者的持有者作為觀點</li></ul></li><li>將組合用於<strong>含有什麼</strong>的關係</li></ul></li></ul><h2 id="設計節省成本的測試"><a href="#設計節省成本的測試" class="headerlink" title="設計節省成本的測試"></a>設計節省成本的測試</h2><ul><li>測試的意圖<ul><li>找出錯誤</li><li>提供文件<ul><li>抱著假設自己將來會得健忘症一樣來撰寫測試</li></ul></li><li>延後設計決定</li><li>支持抽象<ul><li>除非程式碼有測試，否則會出現一層幾乎無法安全做出任何修改的設計抽象</li></ul></li><li>暴露出設計缺陷<ul><li>如果一項測試需要麻煩的設定，就表示程式碼期望過多的上下文</li><li>如果測試某個物件會將一大堆的其他物件捲進來，這表示程式碼有著大量的依賴關係</li><li>如果測試難以撰寫，那麼其他物件也將會發現這段程式碼難以重複使用</li></ul></li></ul></li><li>測試的內容<ul><li>所有事物只測試一次，並且要在適當的地方進行</li><li>將每個物件當成一個黑盒子</li><li>針對定義在公共介面的訊息撰寫測試</li><li>輸入訊息應該測試其傳回狀態，輸出的命令訊息(command)應該測試是否被傳送(行為測試)，而輸出的查詢訊息(query)則不應該被測試。</li></ul></li><li>測試的方法<ul><li>由外向內的 BDD</li><li>由內向外的 TDD</li></ul></li><li>不要測試沒有依賴關係的輸入訊息，而是刪除它：刪除未使用的程式碼能夠立即節省成本，保留未使用的程式碼比刪除之後再恢復他們所花費的成本更高</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Ruby </tag>
            
            <tag> Design </tag>
            
            <tag> Object-Oriented </tag>
            
            <tag> SOLID </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code - 無瑕的程式碼</title>
      <link href="/2020/06/06/clean-code/"/>
      <url>/2020/06/06/clean-code/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，想跟大家分享最近在閱讀的書：<a href="https://www.tenlong.com.tw/products/9789862017050?list_name=e-106" target="_blank" rel="noopener">無瑕的程式碼－敏捷軟體開發技巧守則 (Clean Code: A Handbook of Agile Software Craftsmanship)</a>，作者是 <a href="https://github.com/unclebob" target="_blank" rel="noopener">Robert C. Martin (人稱 Uncle Bob)</a>，是一本對程式設計具代表性的書。預計之後會邊看邊將每章閱讀過後的重點及心得整理成一篇文章分享給大家。</p><h2 id="為什麼要閱讀-Clean-Code？"><a href="#為什麼要閱讀-Clean-Code？" class="headerlink" title="為什麼要閱讀 Clean Code？"></a>為什麼要閱讀 Clean Code？</h2><p>想先跟大家分享我想看這本書的原因，主要是因為在工作中曾經被同事唸過我寫了奇怪的程式碼，剛開始工作在開發時我會有 Cindy 的 100 種寫法(這邊的 100 是誇飾)，總之我會寫了之後又改掉、又再重寫、又再改掉、再重寫，始終不清楚怎麼寫才是好的寫法，畢竟要達到功能的實現，本來就有很多的方式，大概就是條條道路通羅馬的概念。對於 Clean Code，我自己目前的想法是<strong>最簡單最困難</strong>，如果說專案的程式碼可以非常清楚的表達目的，即看起來很簡單，讓接手專案的人都可以快速地上手，是我心中的 Clean Code，但其實想要達到如此境界確實是不容易的一件事情，尤其是當專案的商業邏輯相當複雜的時候，一不小心就會被牽著走，所以希望藉由這本書，提升自己的能力，為了成為更好的程式設計師。</p><h2 id="無瑕的程式碼"><a href="#無瑕的程式碼" class="headerlink" title="無瑕的程式碼"></a>無瑕的程式碼</h2><p>Uncle Bob 在書中第一章節首先對無瑕的程式碼進行說明，表示程式碼將一直存在，所以無可避免我們始終會面對現有的程式碼，而如果我們必須面對劣質的程式碼，那麼開發時間的上升絕對是必然的，因為我們必須花更多的時間去理解雜亂的程式碼。作者提出了一個關於<strong>態度</strong>的觀點，表示保護程式碼是我們的工作，即使我們被開發時程推著走的時候也應該要提出程式現況有多少的風險，這些風險是否會讓未來的開發付出更大的代價，表現出我們的專業。</p><h2 id="最根本的難題"><a href="#最根本的難題" class="headerlink" title="最根本的難題"></a>最根本的難題</h2><p>讓開發速度變快的<strong>唯一</strong>方法是隨時隨地都確保程式碼整齊潔淨。這邊我想如果要做到的話，其實邊開發邊檢視是否需要重構是必要的，因為也許在新的需求進來的時候，程式應該要如何設計的面貌會更清晰，所以作者曾經在 <a href="https://www.youtube.com/watch?v=2dKZ-dWaCiU&t=3616" target="_blank" rel="noopener">ITkonekt 2019</a> 的演講說過我們如果可以延遲應該盡量先延遲某些決定。</p><h2 id="什麼是-Clean-Code？"><a href="#什麼是-Clean-Code？" class="headerlink" title="什麼是 Clean Code？"></a>什麼是 Clean Code？</h2><p>這邊作者認為每個人對於 Clean Code 會有不同的看法，所以列了一些他請教不同資深程式設計師的說法，其中 Bjarne Stroustrup (<a href="https://www.tenlong.com.tw/products/9789863476030" target="_blank" rel="noopener">The C++ Programming Language</a> 的作者) 表示 Clean Code 對細節相當在意，如：<a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" target="_blank" rel="noopener">記憶體流失(memory leak)</a>、<a href="https://zh.wikipedia.org/zh-tw/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener">競爭情況(race condition)</a>、不一致的命名方式(下一篇文章會介紹)……等等。Grady Booch (<a href="https://www.tenlong.com.tw/products/9789861816074" target="_blank" rel="noopener">Object-Oriented Analysis and Design with Applications</a> 的作者) 指出我們撰寫的程式碼應該說明事實，不該使人臆測。這邊我指出幾個印象深刻的，想看更多的大家可以去買書看看唷。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>作者表示我們可以把此書當作是<strong>整潔程式碼之物件學派</strong>，可以學到如何寫出整潔又專業的程式碼，但不要當作這些絕對是<strong>對的</strong>，還有其他不同學派值得我們學習。</p><p>最後下面兩點指出我們要寫 Clean Code 的原因：</p><ul><li>當我們要撰寫程式碼前，其實花了不少功夫在不斷的了解舊的程式碼。</li><li>你今天寫程式的難易度，取決於周遭程式碼的可讀性高低。</li></ul><p>下一篇會介紹有意義的命名，敬請期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Coding </tag>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料庫 Transaction(交易)</title>
      <link href="/2020/05/31/Database-Transaction/"/>
      <url>/2020/05/31/Database-Transaction/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，非資訊科系相關背景的工程師，對於資料庫始終有許多的不理解，今天想跟大家分享我在網路上找到適合非本科系的同學們看的資料，以及分享一些我對於資料庫 <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">Ttansaction</a> 的理解。</p><h2 id="網路上的相關資料"><a href="#網路上的相關資料" class="headerlink" title="網路上的相關資料"></a>網路上的相關資料</h2><ul><li><p><a href="http://debussy.im.nuu.edu.tw/sjchen/DataBaseMan_Final.html" target="_blank" rel="noopener">資料庫系統管理課程</a><br>關於資料庫 Transaction(交易) 可以看 <strong>Course 8. 交易處理</strong> 和 <strong>Course 9. 並行控制與回復</strong>，裡面有 <strong>杰哥數位教室</strong> youtube 課程可以搭配講義學習，雖然 youtube 音質不是很好，但整體看下來對於沒有上過資料庫課程的工程師，我覺得對於觀念的理解會蠻有幫助的。</p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">MySQL 文件</a></p></li><li><p><a href="https://docs.postgresql.tw/tutorial/advanced-features/transactions" target="_blank" rel="noopener">PostgreSQL 文件</a></p></li><li><p><a href="https://docs.postgresql.tw/the-sql-language/concurrency-control/transaction-isolation" target="_blank" rel="noopener">PostgreSQL 文件 - isolation</a><br>MySQL 和 PostgreSQL 算是目前常用到的資料庫系統，如果在實務上有需要了解的時候，直接看文件會最快，因為各個資料庫系統實作的演算法不同。</p></li></ul><h2 id="什麼是-Transaction"><a href="#什麼是-Transaction" class="headerlink" title="什麼是 Transaction"></a>什麼是 Transaction</h2><p>如果有這樣的情境：某個功能需要對資料庫進行操作，且是對一或多筆資料進行操作，如果中間發生失敗，是不會允許有些資料變更成功，有些資料變更失敗的話，就會需要 Transaction。</p><h3 id="MySQL-關於-Transaction-的描述"><a href="#MySQL-關於-Transaction-的描述" class="headerlink" title="MySQL 關於 Transaction 的描述"></a>MySQL 關於 Transaction 的描述</h3><blockquote><p>Transactions are atomic units of work that can be <strong>committed</strong> or <strong>rolled back</strong>. When a transaction makes multiple changes to the database, either all the changes succeed when the transaction is committed, or all the changes are undone when the transaction is rolled back.</p><p>Database transactions, as implemented by InnoDB, have properties that are collectively known by the acronym <strong>ACID</strong>, for atomicity, consistency, isolation, and durability.</p><p>See Also ACID, commit, <strong>isolation level</strong>, <strong>lock</strong>, rollback.</p></blockquote><h3 id="PostgreSQL-關於-Transaction-的描述"><a href="#PostgreSQL-關於-Transaction-的描述" class="headerlink" title="PostgreSQL 關於 Transaction 的描述"></a>PostgreSQL 關於 Transaction 的描述</h3><blockquote><p>Transactions are a fundamental concept of all database systems. The essential point of a transaction is that it bundles multiple steps into a single, <strong>all-or-nothing</strong> operation. The intermediate states between the steps are not visible to other concurrent transactions, and if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all.</p></blockquote><p>由以上內容可以看到關鍵字 <strong>committed</strong> or <strong>rolled back</strong> ，表示的是 Transaction 的兩種情況：</p><ul><li>成功：committed</li><li>失敗：rolled back</li></ul><p>其實也就是 <strong>all-or-nothing</strong> 的表示，要不是全部成功(all)就是全部失敗(nothing)。<br>最常見的例子就是轉帳，假如小明要轉帳給小美，我們不會希望有轉一半的情況發生，例如小明成功扣了轉帳出去的錢，而小美卻沒有得到小明轉進帳戶的錢，所以我們就會需要 Transaction 來幫助我們做到 <strong>all-or-nothing</strong>。<br>=&gt; 詳細參考資料：<a href="http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch09.pdf" target="_blank" rel="noopener">交易管理</a></p><h2 id="Transaction-的四大特性-ACID"><a href="#Transaction-的四大特性-ACID" class="headerlink" title="Transaction 的四大特性 ACID"></a>Transaction 的四大特性 ACID</h2><ul><li>單元性 (<strong>Atomicity</strong>；基元性)：<ul><li>交易是一個不可再分割的完整個體，它不是全部執行，就是全部不執行。</li><li>確保單元性是回復 (<strong>Recovery</strong>) 的責任。</li></ul></li><li>一致性 (<strong>Consistency</strong>)：<ul><li>如果交易是全部執行，能讓資料庫從某個一致狀態，轉變到另一個一致狀態。我們則稱此次交易具有一致性。</li><li>確保一致性通常是 DBMS 程式設計師的責任。</li></ul></li><li>孤立性 (<strong>Isolation</strong>)：<ul><li>某交易執行期間所用的資料或中間結果，不容許其它交易讀取或寫入，直到此交易被確認 (Commit，即：成功結束) 為止。也就是說，它不應被同時執行的其它交易所干擾。</li><li>確保孤立性是並行控制 (<strong>Concurrency Control</strong>) 的責任。可依需求定立不同層級的限制。</li></ul></li><li>永久性 (<strong>Durability</strong>, Permanency)：<ul><li>一旦交易全部執行，且經過確認 (Commit) 後，其對資料庫所做的變更則永遠有效，即使未來系統當機或毀損。</li><li>一般是以備份(Back Up)、硬碟映射(Disk Mirroring)、系統日誌(System Log、System Journal)等數種方式來達成。</li><li>永久性是回復 (<strong>Recovery</strong>) 的責任。</li></ul></li></ul><p>由上面敘述就可以知道，實現 Transaction 最重要的兩件事情就是：</p><ol><li><strong>失敗回復、復原 (Failure Recovery)</strong></li><li><strong>並行控制 (Concurrency Control)</strong><br>=&gt; 詳細參考資料：<a href="http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch10.pdf" target="_blank" rel="noopener">並行控制與回復</a></li></ol><h2 id="SQL-標準中定義了四種數據庫的隔離級別"><a href="#SQL-標準中定義了四種數據庫的隔離級別" class="headerlink" title="SQL 標準中定義了四種數據庫的隔離級別"></a>SQL 標準中定義了四種數據庫的隔離級別</h2><p><img src="https://i.imgur.com/JmoBqZz.png" alt=""></p><blockquote><p>圖片來自 <a href="https://docs.postgresql.tw/the-sql-language/concurrency-control/transaction-isolation" target="_blank" rel="noopener">PostgreSQL 文件</a></p><ul><li>RAED UNCOMMITED：使用查詢語句不會加鎖，可能會讀到未提交的資料（Dirty Read）</li><li>READ COMMITED：只對記錄加記錄鎖，而不會在記錄之間加間隙鎖，所以允許新的記錄插入到被鎖定記錄的附近，所以再多次使用查詢語句時，可能得到不同的結果（Non-Repeatable Read）</li><li>REPEATABLE READ：多次讀取同一範圍的數據會返回第一次查詢的快照，不會返回不同的數據行，但是可能發生幻讀（Phantom Read）</li><li>SERIALIZABLE：InnoDB 隱式地將全部的查詢語句加上共享鎖，解決了幻讀的問題</li></ul></blockquote><p>p.s. MySQL 的 InnoDB 預設的是 Repeatable Read<br>p.s. PostgreSQL 預設的是 Read Committed</p><h2 id="其他可參考資料："><a href="#其他可參考資料：" class="headerlink" title="其他可參考資料："></a>其他可參考資料：</h2><ul><li><a href="https://blog.fntsr.tw/articles/904/#fn-904-START%20TRANSACTION" target="_blank" rel="noopener">PostgreSQL 與 MySQL 關於 transaction 的設計理念</a></li><li><a href="https://kkc.github.io/2017/10/08/transaction-note" target="_blank" rel="noopener">Transaction 筆記</a></li><li><a href="https://vladmihalcea.com/a-beginners-guide-to-acid-and-database-transactions" target="_blank" rel="noopener">A beginner’s guide to ACID and database transactions</a></li><li><a href="https://www.guru99.com/dbms-transaction-management.html" target="_blank" rel="noopener">DBMS Transaction Management: ACID Properties, Schedule</a></li><li><a href="https://draveness.me/mysql-transaction" target="_blank" rel="noopener">『浅入深出』MySQL 中事务的实现</a></li><li><a href="http://coding-geek.com/how-databases-work" target="_blank" rel="noopener">How does a relational database work</a></li><li><a href="https://vinta.ws/code/locking-and-mvcc-in-mysql-innodb.html" target="_blank" rel="noopener">Locking and MVCC in MySQL InnoDB 鎖機制與多版本並發控制</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> PostgreSQL </tag>
            
            <tag> Database </tag>
            
            <tag> Transaction </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新部落格開張</title>
      <link href="/2020/05/28/first-post/"/>
      <url>/2020/05/28/first-post/</url>
      
        <content type="html"><![CDATA[<p>大家好，我決定要把讀書的筆記寫在這個部落格了，敬請期待？</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
