<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ruby 物件導向設計實踐－敏捷入門</title>
      <link href="/2020/06/09/Practical-Object-Oriented-Design-in-Ruby/"/>
      <url>/2020/06/09/Practical-Object-Oriented-Design-in-Ruby/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近在整理 medium 舊的文章 <a href="https://medium.com/@cindyliu923/ruby-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%AF%A6%E8%B8%90%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-e0a357e3fd17" target="_blank" rel="noopener"><strong>Ruby 物件導向設計實踐讀書筆記</strong></a>，想把這篇也放在這裡，但覺得需要重新整理一下，<del>就跟過了一陣子再看我寫的程式碼一樣</del>，所以這篇文章就此誕生？</p><p>首先跟大家說一下，<a href="https://www.tenlong.com.tw/products/9789864340101" target="_blank" rel="noopener">Ruby 物件導向設計實踐－敏捷入門 (Practical Object-Oriented Design in Ruby: An Agile Primer)</a> 是一本書，作者是 <a href="https://www.sandimetz.com" target="_blank" rel="noopener">Sandi Metz</a> 致力推行物件導向程式設計的實踐，出了兩本書 Practical Object-Oriented Design (POODR) 和 <a href="https://www.sandimetz.com/99bottles" target="_blank" rel="noopener">99 Bottles of OOP</a>，都是關於物件導向設計要如何實踐，而且最近發現 Sandi Metz 有很多場精彩的演講，大家可以去看看：</p><ul><li><a href="https://www.youtube.com/watch?v=v-2yFMzxqwU" target="_blank" rel="noopener">GORUCO 2009 - SOLID Object-Oriented Design by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=8bZh5LMaSmE" target="_blank" rel="noopener">RailsConf 2014 - All the Little Things by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=OMPfEXIlTVE" target="_blank" rel="noopener">RailsConf 2015 - Nothing is Something</a></li><li><a href="https://www.youtube.com/watch?v=PJjHfa5yxlU" target="_blank" rel="noopener">RailsConf 2016 - Get a Whiff of This by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=mpA2F1In41w" target="_blank" rel="noopener">hafentalks #7 - Sandi Metz: “Go Ahead, Make a Mess”</a></li></ul><p><strong>接下來是我在閱讀這本書每一章節的筆記，我另外在下面用註解的方式針對我的筆記做說明</strong></p><blockquote><p>參考程式碼如果是 A 這種沒意義的命名請不要認真覺得要這樣寫唷，只是懶得想例子而已，記得要做有意義的命名。</p></blockquote><h2 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h2><ul><li><a href="#物件導向的設計">物件導向的設計</a></li><li><a href="#設計具有單一職責的類別">設計具有單一職責的類別</a></li><li><a href="#管理依賴關係">管理依賴關係</a></li><li><a href="#建立靈活的介面">建立靈活的介面</a></li><li><a href="#使用鴨子類型技巧降低成本">使用鴨子類型技巧降低成本</a></li><li><a href="#藉由繼承取得行為">藉由繼承取得行為</a></li><li><a href="#使用模組共用角色行為">使用模組共用角色行為</a></li><li><a href="#組合物件">組合物件</a></li><li><a href="#設計節省成本的測試">設計節省成本的測試</a></li></ul><h2 id="物件導向的設計"><a href="#物件導向的設計" class="headerlink" title="物件導向的設計"></a>物件導向的設計</h2><ul><li><p>物件導向設計與依賴關係管理相關</p><ul><li>不受管理的依賴關係很容易造成嚴重破壞，因為物件之間彼此了解太多<blockquote><p>依賴關係其實就是如果某個物件的修改會影響到另一個物件，我們就可以說這兩個物件具有依賴關係</p></blockquote></li></ul></li><li><p>設計的目的是使你日後仍然可以繼續設計</p></li><li><p>設計原則</p><ul><li><p>SOLID</p><ul><li><p>單一職責(Single Responsibility Principle, SRB)</p><blockquote><p>簡單說就是一個物件只做一件事情</p></blockquote></li><li><p>開閉原則(Open-Closed Principle, OCP)</p><blockquote><p>在設計已經完整的前提下只能增加程式碼，不能改既有的程式碼</p></blockquote></li><li><p>里氏代替原則(Liskov Substitution Principle, LSP)</p><blockquote><p>若是使用繼承，子類別實作的行為必須要與父類別或是介面所定義的行為一致，並且子類別要能夠完全取代掉父類別</p></blockquote></li><li><p>介面隔離原則(Interface Segregation Principle, ISP)</p><blockquote><p>No client should be forced to depend on methods it does not use.</p></blockquote></li><li><p>依賴倒置原則(Dependency Inversion Principle, DIP)</p><blockquote><p>簡單講是物件之間的依賴關係的處理，可參考<a href="https://notfalse.net/1/dip" target="_blank" rel="noopener">這篇文章</a>，雖然範例不是 Ruby，但我覺得說明的蠻有趣的，如果說看完文章想轉成 Ruby 的話最後結果類似下面這段程式碼，其中 <code>stuffer</code> 是抽象介面，即實際上並不存在 <code>stuffer</code> 的類別</p></blockquote></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(stuffer)</span></span></span><br><span class="line">    stuffer.new.stuff</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stuff</span></span></span><br><span class="line">    p <span class="string">'咔拉雞腿滿福堡 好棒棒'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spaghetti</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stuff</span></span></span><br><span class="line">    p <span class="string">'大蒜辣椒麵 :D'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">People.new.eat(Hamburger)</span><br><span class="line">People.new.eat(Spaghetti)</span><br></pre></td></tr></table></figure></li><li><p>Don’t Repeat Yourself, DRY</p></li><li><p>Law of Demeter, LoD</p></li></ul></li><li><p>若未進行設計 =&gt; 我可以增加這項功能，但這會把所有東西破壞。</p></li></ul><h2 id="設計具有單一職責的類別"><a href="#設計具有單一職責的類別" class="headerlink" title="設計具有單一職責的類別"></a>設計具有單一職責的類別</h2><ul><li>程式碼應具備的特點(TRUE)<ul><li>透明性(Transparent)-程式碼的修改結果要顯而易見</li><li>合理性(Reasonable)-修改的成本要跟修改後的效益成正比</li><li>可用性(Usable)-既有程式碼在任何時候都要保持可用</li><li>典範性(Examplary)-程式碼本身鼓勵為延續這些特點的修改</li></ul></li><li>判斷方法<ul><li>嘗試用一句話描述類別(Class)，若描述中出現<strong>和</strong>、<strong>或</strong>表示不只做一件事情</li><li>高聚合-這個類別所做的所有事情都與其目標非常相關</li></ul></li><li>依賴<strong>行為</strong>而非資料<blockquote><p>資料庫的相關書籍也有提到說應用程式跟資料應該要分離，在寫程式的時候不應該依賴資料內容才對，否則會有應用程式與資料黏在一起的感覺啊，會進入越來越難寫的窘境</p></blockquote></li><li>只負責單一事物的類別能夠將事物與應用程式的其他部分有所<strong>隔離</strong></li></ul><h2 id="管理依賴關係"><a href="#管理依賴關係" class="headerlink" title="管理依賴關係"></a>管理依賴關係</h2><ul><li>低耦合</li><li>依賴像膠水，類別和接觸到他的事物黏在一起，存在幾滴膠水是有必要的，但如果膠水太多，應用程式會凝結成堅固的一塊</li><li>依賴注入(dependency injection)<blockquote><p>用這樣的方式其實就表示說當 A 和 B 必須具有依賴關係的時候，寧願讓依賴是 B 從外面丟進去 A 裡面，也不要是包在 A 裡面不容易察覺的地方</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @y = y</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * y.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># B 從外面丟進去 A 裡面</span></span><br><span class="line">A.new(x, B.new(...))</span><br></pre></td></tr></table></figure></li><li>隔離依賴<ul><li>隔離實例建立(當無法使用<strong>依賴注入</strong>時)<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一種方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b</span></span></span><br><span class="line">    @b <span class="params">||</span>= B.new(...)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 第二種方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @b <span class="params">||</span>= B.new(...)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * @b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>隔離外部訊息<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 將外部訊息 b_method 隔離出來(似乎可以用委派)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b_method</span></span></span><br><span class="line">    b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>移除參數順序依賴<ul><li>使用 Hash<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span>, <span class="symbol">:z</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">    @x = args[<span class="symbol">:x</span>]</span><br><span class="line">    @y = args[<span class="symbol">:y</span>]</span><br><span class="line">    @z = args[<span class="symbol">:z</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>明確定義預設值<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">  @x = args[<span class="symbol">:x</span>] <span class="params">||</span> <span class="number">5</span></span><br><span class="line">  @y = args[<span class="symbol">:y</span>] <span class="params">||</span> <span class="number">10</span></span><br><span class="line">  <span class="comment"># 如果是 boolean 下面這樣寫會有問題，全部都變成 true</span></span><br><span class="line">  @z = args[<span class="symbol">:z</span>] <span class="params">||</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 可以改使用 fetch 來寫</span></span><br><span class="line">  @z = args.fetch(<span class="symbol">:z</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 merge</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">  args = defaults.merge(args)</span><br><span class="line">  @x = args[<span class="symbol">:x</span>]</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaults</span></span></span><br><span class="line">  &#123;<span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>隔離多重參數初始化操作<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 當 A 是外部介面的一部分時</span></span><br><span class="line"><span class="comment"># 例如某個框架的東西，對我來說是不能修改的部分</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">SomeFramework</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span>, <span class="symbol">:z</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y, z)</span></span></span><br><span class="line">      @x = x</span><br><span class="line">      @y = y</span><br><span class="line">      @z = z</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將外部介面包裝起來</span></span><br><span class="line"><span class="comment"># 為某個特定類別建立實例，可以稱之為 factory，</span></span><br><span class="line"><span class="comment"># 當被迫無法修改外部介面時可以使用的技巧</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">AWrapper</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">a</span><span class="params">(args)</span></span></span><br><span class="line">    SomeFramework::A.new(args[<span class="symbol">:x</span>], args[<span class="symbol">:y</span>], arg[<span class="symbol">:z</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>選擇依賴方向<ul><li>告訴類別他們要依賴那些變化少於他們自身的事物<ul><li>有些類別更容易發生變化</li><li>具體類別比抽象類別更容易發生變化</li><li>修改具有許多依賴關係的類別會造成廣泛的影響<blockquote><p>這邊可以參考上面提到的 SOLID 的 <strong>依賴倒置原則(Dependency Inversion Principle, DIP)</strong></p></blockquote></li></ul></li></ul></li></ul><h2 id="建立靈活的介面"><a href="#建立靈活的介面" class="headerlink" title="建立靈活的介面"></a>建立靈活的介面</h2><ul><li>定義介面<ul><li>公共介面<ul><li>顯露出主要職責</li><li>期望被其他物件呼叫</li><li>不會隨便改變</li><li>其他物件可以放心依賴它</li><li>在測試裡被詳盡記錄</li></ul></li><li>私有介面<ul><li>要處理實作細節</li><li>不希望被傳送到其它物件</li><li>可因任何原因變化</li><li>其他物件不能放心依賴它</li><li>可能不會在測試裡被引用</li></ul></li></ul></li><li>關鍵字(Ruby 裡的方法)<ul><li>public</li><li>protected</li><li>private</li><li>可參考資料：<a href="https://kaochenlong.com/2011/07/26/public-protected-and-private-method-in-ruby" target="_blank" rel="noopener">Public, Protected and Private Method in Ruby</a></li></ul></li><li><strong>詢問傳送方想要什麼</strong>而非<strong>告訴接收者如何表現</strong><ul><li>表示物件之間彼此信任</li></ul></li><li>Law of Demeter, LoD<ul><li>對物件之間的傳遞進行限制：禁止將一則訊息藉由第二個不同的物件轉發給第三個物件，即<strong>只能與你的鄰近對話</strong>或<strong>只能使用一個小圓點</strong></li><li>小心使用委派(delegate) - Ruby 的 <code>delegate.rb</code>、<code>forwardable.rb</code>，Rails 的 <code>delegate</code> 方法</li></ul></li></ul><h2 id="使用鴨子類型技巧降低成本"><a href="#使用鴨子類型技巧降低成本" class="headerlink" title="使用鴨子類型技巧降低成本"></a>使用鴨子類型技巧降低成本</h2><ul><li>鴨子類型(duck typing)<ul><li>多態性(polymorphism):許多不同物件回應相同訊息的能力，duck typing 是實作多態性的方法之一<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(preparers)</span></span></span><br><span class="line">    preparers.each <span class="keyword">do</span> <span class="params">|preparer|</span></span><br><span class="line">      preparer.prepare_something(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 特定的 type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare_something</span><span class="params">(a)</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 特定的 type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare_something</span><span class="params">(a)</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="藉由繼承取得行為"><a href="#藉由繼承取得行為" class="headerlink" title="藉由繼承取得行為"></a>藉由繼承取得行為</h2><ul><li>classical inheritance<ul><li>繼承的核心是一種用於實作<strong>訊息自動委派</strong>的機制</li></ul></li><li>如果程式碼中的傳送者可以說話，如果說出：<strong>我知道你是誰，因為我知道你會做什麼</strong>，這項知識是一種會增加修改成本的依賴關係</li><li>建立抽象父類別<blockquote><p>這裡會寫說抽象是因為實際上我們不會去 new 一個父類別出來使用，而是會針對不同的情況 new 出不一樣的子類別，所以我們說是將行為提升至抽象，而子類別我們就會說是具體的</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildernB</span> &lt; Father</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>提升抽象行為<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:specific</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">    <span class="keyword">super</span>(args) <span class="comment"># 子類別現在"必須"傳送 super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>從具體分離出抽象<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    <span class="comment"># 本來兩個子類別方法中共用的參數</span></span><br><span class="line">    <span class="comment"># 從具體的子類別中分離出來</span></span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>]</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用範本方法模式(<strong>template method pattern</strong>)<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>] <span class="params">||</span> default_arg1</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>] <span class="params">||</span> default_arg2</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 共同的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg1</span></span></span><br><span class="line">    <span class="string">'10-arg1'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    <span class="string">'23'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildernB</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    <span class="string">'2.1'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>實作所有的範本方法(<strong>template method</strong>)<ul><li>將子類別的方法寫進父類別中，即使是不做事也要實作該方法，讓工程師知道繼承這個類別時一定要實作哪些方法<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 只要在當下稍微用心一點，</span></span><br><span class="line">  <span class="comment"># 建立出在失敗時帶有合理錯誤訊息的程式碼，</span></span><br><span class="line">  <span class="comment"># 就能夠得到永久性的益處</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    raise NotImplementedError,</span><br><span class="line">      <span class="string">"This <span class="subst">#&#123;<span class="keyword">self</span><span class="class">.<span class="keyword">class</span>&#125; <span class="title">cannot</span> <span class="title">respond</span> <span class="title">to</span>:"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">  <span class="keyword">end</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="keyword">end</span></span></span></span><br></pre></td></tr></table></figure></li></ul></li><li>父子間的耦合管理<ul><li>緊密耦合的類別會黏再一起，並且可能無法單獨修改<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:specific</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">    <span class="keyword">super</span>(args) <span class="comment"># 子類別現在"必須"傳送 super</span></span><br><span class="line">    <span class="comment"># 這個 super 造成父子之間的耦合</span></span><br><span class="line">    <span class="comment"># 強迫子類別知道如何與其抽象父類別互動</span></span><br><span class="line">    <span class="comment"># 將演算法的知識下放到子類別裡</span></span><br><span class="line">    <span class="comment"># 導致程式碼在多個子類別中重複</span></span><br><span class="line">    <span class="comment"># 並且需要所有子類別在完全相同的地方傳送 super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 父類別有一樣的方法</span></span><br><span class="line">  <span class="comment"># 同上形成耦合</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">other</span></span></span><br><span class="line">    <span class="keyword">super</span>.merge(hash)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用鉤子(hook)訊息解耦<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>] <span class="params">||</span> default_arg1</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>] <span class="params">||</span> default_arg2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提供子類別使用</span></span><br><span class="line">    post_initialize(args)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 實作方法，但不做事</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別可選擇性覆蓋這個方法</span></span><br><span class="line">  <span class="comment"># 子類別不再控制初始化</span></span><br><span class="line">  <span class="comment"># 將特殊化提供給更大型的抽象演算法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">other</span></span></span><br><span class="line">    &#123;<span class="symbol">a:</span> <span class="string">'a'</span>, <span class="symbol">b:</span> <span class="string">'b'</span>&#125;.merge(local_other)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用於子類別覆蓋的 hook</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">local_other</span></span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 不用強迫子類別知道父類別實作了 other 的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">local_other</span></span></span><br><span class="line">    &#123;<span class="symbol">c:</span> <span class="string">'c'</span>&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用 hook 方法可以讓繼承者不用強迫傳送 super，並且還能提供特殊化內容</li></ul></li></ul><h2 id="使用模組共用角色行為"><a href="#使用模組共用角色行為" class="headerlink" title="使用模組共用角色行為"></a>使用模組共用角色行為</h2><ul><li>理解物件所扮演的角色，找出隱藏角色，建立程式碼，以便在多個扮演者之間共用行為，同時要最小化其中所產生的依賴關係</li><li>ruby 的模組(module)<ul><li>撰寫技巧與繼承相似，但模組更在乎的是<strong>像什麼</strong>，而繼承是<strong>是什麼</strong><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/skmetz/poodr2/blob/master/7_10.rb</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Schedulable</span></span></span><br><span class="line">  <span class="keyword">attr_writer</span> <span class="symbol">:schedule</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span></span><br><span class="line">    @schedule <span class="params">||</span>= Schedule.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedulable?</span><span class="params">(starting, ending)</span></span></span><br><span class="line">    !scheduled?(starting - lead_days, ending)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">scheduled?</span><span class="params">(starting, ending)</span></span></span><br><span class="line">    schedule.scheduled?(<span class="keyword">self</span>, starting, ending)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 包含者可以加以覆蓋</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lead_days</span></span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>找尋方法的順序<ul><li>單例類別(Singleton class 只在這個 instance 所定義的方法)-&gt;模組(extend instance 的 module 所定義的方法)-&gt;類別-&gt;類別包含的模組-&gt;父類別-&gt;父類別包含的模組-&gt;Object …</li><li><a href="https://www.spreered.com/ruby-object-model-1" target="_blank" rel="noopener">Ruby 的繼承鍊 (1) - 如何實踐物件導向</a></li><li><a href="https://www.spreered.com/ruby-object-model-include-prepend-extend" target="_blank" rel="noopener">Ruby 的繼承鍊 (2) - Module 的 include、prepend 和 extend</a></li></ul></li><li><strong>抽象父類別裡的所有程式碼都應該適用於每個繼承他的類別</strong>，父類別不應該包含只適用於部分(而非全部)子類別的程式碼，這項限制也同樣應用在模組上：<strong>模組裡的程式碼必須也能夠一併適用於包含他的所有事物</strong></li><li>里氏代替原則(Liskov Substitution Principle, LSP)：子類型必須能夠代替他們的父類型</li></ul><h2 id="組合物件"><a href="#組合物件" class="headerlink" title="組合物件"></a>組合物件</h2><ul><li>composition<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'forwardable'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parts</span></span></span><br><span class="line">  extend Forwardable</span><br><span class="line">  def_delegators <span class="symbol">:</span>@parts, <span class="symbol">:size</span>, <span class="symbol">:each</span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(parts)</span></span></span><br><span class="line">    @parts = parts</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">    select &#123;<span class="params">|part|</span> part.needs_spare&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Struct 接收的是按順序排列的初始化參數，</span></span><br><span class="line"><span class="comment"># 而 OpenStruct 在初始化時則是接收一個 Hash</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'ostruct'</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">PartsFactory</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">build</span><span class="params">(config, parts_class = Parts)</span></span></span><br><span class="line">    parts_class.new(</span><br><span class="line">      config.collect &#123;<span class="params">|part_config|</span></span><br><span class="line">        create_part(part_config)&#125;)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">create_part</span><span class="params">(part_config)</span></span></span><br><span class="line">    OpenStruct.new(</span><br><span class="line">      <span class="symbol">name:</span>        part_config[<span class="number">0</span>],</span><br><span class="line">      <span class="symbol">description:</span> part_config[<span class="number">1</span>],</span><br><span class="line">      <span class="symbol">needs_spare:</span> part_config.fetch(<span class="number">2</span>, <span class="literal">true</span>))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/skmetz/poodr/blob/master/chapter_8.rb#L422</span></span><br></pre></td></tr></table></figure></li><li>組合允許物件之間的結構獨立性，其代價是需要明確進行訊息委派</li><li>如果問題可以使用組合技巧解決，應該盡可能使用組合，如果無法明確保證繼承是一種更好的解決方案，要用組合，因為組合的依賴關係比繼承少許多</li><li>選擇關係：<ul><li>將繼承用於<strong>是什麼</strong>的關係</li><li>將 duck typing 用於<strong>表現得像什麼</strong>的關係<ul><li>思考角色最明確的方法是從外部，以角色扮演者的持有者作為觀點</li></ul></li><li>將組合用於<strong>含有什麼</strong>的關係</li></ul></li></ul><h2 id="設計節省成本的測試"><a href="#設計節省成本的測試" class="headerlink" title="設計節省成本的測試"></a>設計節省成本的測試</h2><ul><li>測試的意圖<ul><li>找出錯誤</li><li>提供文件<ul><li>抱著假設自己將來會得健忘症一樣來撰寫測試</li></ul></li><li>延後設計決定</li><li>支持抽象<ul><li>除非程式碼有測試，否則會出現一層幾乎無法安全做出任何修改的設計抽象</li></ul></li><li>暴露出設計缺陷<ul><li>如果一項測試需要麻煩的設定，就表示程式碼期望過多的上下文</li><li>如果測試某個物件會將一大堆的其他物件捲進來，這表示程式碼有著大量的依賴關係</li><li>如果測試難以撰寫，那麼其他物件也將會發現這段程式碼難以重複使用</li></ul></li></ul></li><li>測試的內容<ul><li>所有事物只測試一次，並且要在適當的地方進行</li><li>將每個物件當成一個黑盒子</li><li>針對定義在公共介面的訊息撰寫測試</li><li>輸入訊息應該測試其傳回狀態，輸出的命令訊息(command)應該測試是否被傳送(行為測試)，而輸出的查詢訊息(query)則不應該被測試。</li></ul></li><li>測試的方法<ul><li>由外向內的 BDD</li><li>由內向外的 TDD</li></ul></li><li>不要測試沒有依賴關係的輸入訊息，而是刪除它：刪除未使用的程式碼能夠立即節省成本，保留未使用的程式碼比刪除之後再恢復他們所花費的成本更高</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Ruby </tag>
            
            <tag> Design </tag>
            
            <tag> Object-Oriented </tag>
            
            <tag> SOLID </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code - 無瑕的程式碼</title>
      <link href="/2020/06/06/clean-code/"/>
      <url>/2020/06/06/clean-code/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，想跟大家分享最近在閱讀的書：<a href="https://www.tenlong.com.tw/products/9789862017050?list_name=e-106" target="_blank" rel="noopener">無瑕的程式碼－敏捷軟體開發技巧守則 (Clean Code: A Handbook of Agile Software Craftsmanship)</a>，作者是 <a href="https://github.com/unclebob" target="_blank" rel="noopener">Robert C. Martin (人稱 Uncle Bob)</a>，是一本對程式設計具代表性的書。預計之後會邊看邊將每章閱讀過後的重點及心得整理成一篇文章分享給大家。</p><h2 id="為什麼要閱讀-Clean-Code？"><a href="#為什麼要閱讀-Clean-Code？" class="headerlink" title="為什麼要閱讀 Clean Code？"></a>為什麼要閱讀 Clean Code？</h2><p>想先跟大家分享我想看這本書的原因，主要是因為在工作中曾經被同事唸過我寫了奇怪的程式碼，剛開始工作在開發時我會有 Cindy 的 100 種寫法(這邊的 100 是誇飾)，總之我會寫了之後又改掉、又再重寫、又再改掉、再重寫，始終不清楚怎麼寫才是好的寫法，畢竟要達到功能的實現，本來就有很多的方式，大概就是條條道路通羅馬的概念。對於 Clean Code，我自己目前的想法是<strong>最簡單最困難</strong>，如果說專案的程式碼可以非常清楚的表達目的，即看起來很簡單，讓接手專案的人都可以快速地上手，是我心中的 Clean Code，但其實想要達到如此境界確實是不容易的一件事情，尤其是當專案的商業邏輯相當複雜的時候，一不小心就會被牽著走，所以希望藉由這本書，提升自己的能力，為了成為更好的程式設計師。</p><h2 id="無瑕的程式碼"><a href="#無瑕的程式碼" class="headerlink" title="無瑕的程式碼"></a>無瑕的程式碼</h2><p>Uncle Bob 在書中第一章節首先對無瑕的程式碼進行說明，表示程式碼將一直存在，所以無可避免我們始終會面對現有的程式碼，而如果我們必須面對劣質的程式碼，那麼開發時間的上升絕對是必然的，因為我們必須花更多的時間去理解雜亂的程式碼。作者提出了一個關於<strong>態度</strong>的觀點，表示保護程式碼是我們的工作，即使我們被開發時程推著走的時候也應該要提出程式現況有多少的風險，這些風險是否會讓未來的開發付出更大的代價，表現出我們的專業。</p><h2 id="最根本的難題"><a href="#最根本的難題" class="headerlink" title="最根本的難題"></a>最根本的難題</h2><p>讓開發速度變快的<strong>唯一</strong>方法是隨時隨地都確保程式碼整齊潔淨。這邊我想如果要做到的話，其實邊開發邊檢視是否需要重構是必要的，因為也許在新的需求進來的時候，程式應該要如何設計的面貌會更清晰，所以作者曾經在 <a href="https://www.youtube.com/watch?v=2dKZ-dWaCiU&t=3616" target="_blank" rel="noopener">ITkonekt 2019</a> 的演講說過我們如果可以延遲應該盡量先延遲某些決定。</p><h2 id="什麼是-Clean-Code？"><a href="#什麼是-Clean-Code？" class="headerlink" title="什麼是 Clean Code？"></a>什麼是 Clean Code？</h2><p>這邊作者認為每個人對於 Clean Code 會有不同的看法，所以列了一些他請教不同資深程式設計師的說法，其中 Bjarne Stroustrup (<a href="https://www.tenlong.com.tw/products/9789863476030" target="_blank" rel="noopener">The C++ Programming Language</a> 的作者) 表示 Clean Code 對細節相當在意，如：<a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" target="_blank" rel="noopener">記憶體流失(memory leak)</a>、<a href="https://zh.wikipedia.org/zh-tw/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener">競爭情況(race condition)</a>、不一致的命名方式(下一篇文章會介紹)……等等。Grady Booch (<a href="https://www.tenlong.com.tw/products/9789861816074" target="_blank" rel="noopener">Object-Oriented Analysis and Design with Applications</a> 的作者) 指出我們撰寫的程式碼應該說明事實，不該使人臆測。這邊我指出幾個印象深刻的，想看更多的大家可以去買書看看唷。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>作者表示我們可以把此書當作是<strong>整潔程式碼之物件學派</strong>，可以學到如何寫出整潔又專業的程式碼，但不要當作這些絕對是<strong>對的</strong>，還有其他不同學派值得我們學習。</p><p>最後下面兩點指出我們要寫 Clean Code 的原因：</p><ul><li>當我們要撰寫程式碼前，其實花了不少功夫在不斷的了解舊的程式碼。</li><li>你今天寫程式的難易度，取決於周遭程式碼的可讀性高低。</li></ul><p>下一篇會介紹有意義的命名，敬請期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Coding </tag>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料庫 Transaction(交易)</title>
      <link href="/2020/05/31/Database-Transaction/"/>
      <url>/2020/05/31/Database-Transaction/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，非資訊科系相關背景的工程師，對於資料庫始終有許多的不理解，今天想跟大家分享我在網路上找到適合非本科系的同學們看的資料，以及分享一些我對於資料庫 <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">Ttansaction</a> 的理解。</p><h2 id="網路上的相關資料"><a href="#網路上的相關資料" class="headerlink" title="網路上的相關資料"></a>網路上的相關資料</h2><ul><li><p><a href="http://debussy.im.nuu.edu.tw/sjchen/DataBaseMan_Final.html" target="_blank" rel="noopener">資料庫系統管理課程</a><br>關於資料庫 Transaction(交易) 可以看 <strong>Course 8. 交易處理</strong> 和 <strong>Course 9. 並行控制與回復</strong>，裡面有 <strong>杰哥數位教室</strong> youtube 課程可以搭配講義學習，雖然 youtube 音質不是很好，但整體看下來對於沒有上過資料庫課程的工程師，我覺得對於觀念的理解會蠻有幫助的。</p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">MySQL 文件</a></p></li><li><p><a href="https://docs.postgresql.tw/tutorial/advanced-features/transactions" target="_blank" rel="noopener">PostgreSQL 文件</a></p></li><li><p><a href="https://docs.postgresql.tw/the-sql-language/concurrency-control/transaction-isolation" target="_blank" rel="noopener">PostgreSQL 文件 - isolation</a><br>MySQL 和 PostgreSQL 算是目前常用到的資料庫系統，如果在實務上有需要了解的時候，直接看文件會最快，因為各個資料庫系統實作的演算法不同。</p></li></ul><h2 id="什麼是-Transaction"><a href="#什麼是-Transaction" class="headerlink" title="什麼是 Transaction"></a>什麼是 Transaction</h2><p>如果有這樣的情境：某個功能需要對資料庫進行操作，且是對一或多筆資料進行操作，如果中間發生失敗，是不會允許有些資料變更成功，有些資料變更失敗的話，就會需要 Transaction。</p><h3 id="MySQL-關於-Transaction-的描述"><a href="#MySQL-關於-Transaction-的描述" class="headerlink" title="MySQL 關於 Transaction 的描述"></a>MySQL 關於 Transaction 的描述</h3><blockquote><p>Transactions are atomic units of work that can be <strong>committed</strong> or <strong>rolled back</strong>. When a transaction makes multiple changes to the database, either all the changes succeed when the transaction is committed, or all the changes are undone when the transaction is rolled back.</p><p>Database transactions, as implemented by InnoDB, have properties that are collectively known by the acronym <strong>ACID</strong>, for atomicity, consistency, isolation, and durability.</p><p>See Also ACID, commit, <strong>isolation level</strong>, <strong>lock</strong>, rollback.</p></blockquote><h3 id="PostgreSQL-關於-Transaction-的描述"><a href="#PostgreSQL-關於-Transaction-的描述" class="headerlink" title="PostgreSQL 關於 Transaction 的描述"></a>PostgreSQL 關於 Transaction 的描述</h3><blockquote><p>Transactions are a fundamental concept of all database systems. The essential point of a transaction is that it bundles multiple steps into a single, <strong>all-or-nothing</strong> operation. The intermediate states between the steps are not visible to other concurrent transactions, and if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all.</p></blockquote><p>由以上內容可以看到關鍵字 <strong>committed</strong> or <strong>rolled back</strong> ，表示的是 Transaction 的兩種情況：</p><ul><li>成功：committed</li><li>失敗：rolled back</li></ul><p>其實也就是 <strong>all-or-nothing</strong> 的表示，要不是全部成功(all)就是全部失敗(nothing)。<br>最常見的例子就是轉帳，假如小明要轉帳給小美，我們不會希望有轉一半的情況發生，例如小明成功扣了轉帳出去的錢，而小美卻沒有得到小明轉進帳戶的錢，所以我們就會需要 Transaction 來幫助我們做到 <strong>all-or-nothing</strong>。<br>=&gt; 詳細參考資料：<a href="http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch09.pdf" target="_blank" rel="noopener">交易管理</a></p><h2 id="Transaction-的四大特性-ACID"><a href="#Transaction-的四大特性-ACID" class="headerlink" title="Transaction 的四大特性 ACID"></a>Transaction 的四大特性 ACID</h2><ul><li>單元性 (<strong>Atomicity</strong>；基元性)：<ul><li>交易是一個不可再分割的完整個體，它不是全部執行，就是全部不執行。</li><li>確保單元性是回復 (<strong>Recovery</strong>) 的責任。</li></ul></li><li>一致性 (<strong>Consistency</strong>)：<ul><li>如果交易是全部執行，能讓資料庫從某個一致狀態，轉變到另一個一致狀態。我們則稱此次交易具有一致性。</li><li>確保一致性通常是 DBMS 程式設計師的責任。</li></ul></li><li>孤立性 (<strong>Isolation</strong>)：<ul><li>某交易執行期間所用的資料或中間結果，不容許其它交易讀取或寫入，直到此交易被確認 (Commit，即：成功結束) 為止。也就是說，它不應被同時執行的其它交易所干擾。</li><li>確保孤立性是並行控制 (<strong>Concurrency Control</strong>) 的責任。可依需求定立不同層級的限制。</li></ul></li><li>永久性 (<strong>Durability</strong>, Permanency)：<ul><li>一旦交易全部執行，且經過確認 (Commit) 後，其對資料庫所做的變更則永遠有效，即使未來系統當機或毀損。</li><li>一般是以備份(Back Up)、硬碟映射(Disk Mirroring)、系統日誌(System Log、System Journal)等數種方式來達成。</li><li>永久性是回復 (<strong>Recovery</strong>) 的責任。</li></ul></li></ul><p>由上面敘述就可以知道，實現 Transaction 最重要的兩件事情就是：</p><ol><li><strong>失敗回復、復原 (Failure Recovery)</strong></li><li><strong>並行控制 (Concurrency Control)</strong><br>=&gt; 詳細參考資料：<a href="http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch10.pdf" target="_blank" rel="noopener">並行控制與回復</a></li></ol><h2 id="SQL-標準中定義了四種數據庫的隔離級別"><a href="#SQL-標準中定義了四種數據庫的隔離級別" class="headerlink" title="SQL 標準中定義了四種數據庫的隔離級別"></a>SQL 標準中定義了四種數據庫的隔離級別</h2><p><img src="https://i.imgur.com/JmoBqZz.png" alt=""></p><blockquote><p>圖片來自 <a href="https://docs.postgresql.tw/the-sql-language/concurrency-control/transaction-isolation" target="_blank" rel="noopener">PostgreSQL 文件</a></p><ul><li>RAED UNCOMMITED：使用查詢語句不會加鎖，可能會讀到未提交的資料（Dirty Read）</li><li>READ COMMITED：只對記錄加記錄鎖，而不會在記錄之間加間隙鎖，所以允許新的記錄插入到被鎖定記錄的附近，所以再多次使用查詢語句時，可能得到不同的結果（Non-Repeatable Read）</li><li>REPEATABLE READ：多次讀取同一範圍的數據會返回第一次查詢的快照，不會返回不同的數據行，但是可能發生幻讀（Phantom Read）</li><li>SERIALIZABLE：InnoDB 隱式地將全部的查詢語句加上共享鎖，解決了幻讀的問題</li></ul></blockquote><p>p.s. MySQL 的 InnoDB 預設的是 Repeatable Read<br>p.s. PostgreSQL 預設的是 Read Committed</p><h2 id="其他可參考資料："><a href="#其他可參考資料：" class="headerlink" title="其他可參考資料："></a>其他可參考資料：</h2><ul><li><a href="https://blog.fntsr.tw/articles/904/#fn-904-START%20TRANSACTION" target="_blank" rel="noopener">PostgreSQL 與 MySQL 關於 transaction 的設計理念</a></li><li><a href="https://kkc.github.io/2017/10/08/transaction-note" target="_blank" rel="noopener">Transaction 筆記</a></li><li><a href="https://vladmihalcea.com/a-beginners-guide-to-acid-and-database-transactions" target="_blank" rel="noopener">A beginner’s guide to ACID and database transactions</a></li><li><a href="https://www.guru99.com/dbms-transaction-management.html" target="_blank" rel="noopener">DBMS Transaction Management: ACID Properties, Schedule</a></li><li><a href="https://draveness.me/mysql-transaction" target="_blank" rel="noopener">『浅入深出』MySQL 中事务的实现</a></li><li><a href="http://coding-geek.com/how-databases-work" target="_blank" rel="noopener">How does a relational database work</a></li><li><a href="https://vinta.ws/code/locking-and-mvcc-in-mysql-innodb.html" target="_blank" rel="noopener">Locking and MVCC in MySQL InnoDB 鎖機制與多版本並發控制</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> PostgreSQL </tag>
            
            <tag> Database </tag>
            
            <tag> Transaction </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新部落格開張</title>
      <link href="/2020/05/28/first-post/"/>
      <url>/2020/05/28/first-post/</url>
      
        <content type="html"><![CDATA[<p>大家好，我決定要把讀書的筆記寫在這個部落格了，敬請期待？</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
