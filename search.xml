<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS50 Lab 2: Scrabble</title>
      <link href="/2020/12/07/CS50-Lab-2-Scrabble/"/>
      <url>/2020/12/07/CS50-Lab-2-Scrabble/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近跟同事小夥伴相約一起看 CS50 的課程，CS50 (Introduction to Computer Science）是一堂美國哈佛大學知名的通識課程，完全免費，在 <a href="https://www.edx.org/course/cs50s-introduction-to-computer-science" target="_blank" rel="noopener">edx</a> 或 <a href="https://www.youtube.com/watch?v=Tpl7k8IOT6E" target="_blank" rel="noopener">youtube</a> 或 <a href="https://github.com/athena-xcy/CS50-Study-Group" target="_blank" rel="noopener">CS50-Study-Group github</a> 都可以非常容易地看到。</p><p>這篇文章是我練習寫 Week 2 的作業(因為不知道要放在哪裡，才不會以後找不到，所以就決定放在部落格啦)，歡迎大家有更好的解法可以一起討論唷～</p><p>題目：<a href="https://cs50.harvard.edu/college/2020/fall/labs/2" target="_blank" rel="noopener">Lab 2: Scrabble</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cs50.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Points assigned to each letter of the alphabet</span></span><br><span class="line"><span class="keyword">int</span> POINTS[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute_score</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get input words from both players</span></span><br><span class="line">    <span class="built_in">string</span> word1 = get_string(<span class="string">"Player 1: "</span>);</span><br><span class="line">    <span class="built_in">string</span> word2 = get_string(<span class="string">"Player 2: "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Score both words</span></span><br><span class="line">    <span class="keyword">int</span> score1 = compute_score(word1);</span><br><span class="line">    <span class="keyword">int</span> score2 = compute_score(word2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the winner</span></span><br><span class="line">    <span class="keyword">if</span> (score1 &gt; score2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Player 1 wins!\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score1 &lt; score2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Player 2 wins!\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Tie!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute_score</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Compute and return score for string</span></span><br><span class="line">    <span class="keyword">int</span> points = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="keyword">word</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(<span class="keyword">word</span>[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            points += POINTS[<span class="keyword">word</span>[i] - <span class="number">65</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(<span class="keyword">word</span>[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            points += POINTS[<span class="keyword">word</span>[i] - <span class="number">97</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CS50 </tag>
            
            <tag> Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS50 Lab 1: Population Growth</title>
      <link href="/2020/12/06/CS50-Lab-1-Population-Growth/"/>
      <url>/2020/12/06/CS50-Lab-1-Population-Growth/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近跟同事小夥伴相約一起看 CS50 的課程，CS50 (Introduction to Computer Science）是一堂美國哈佛大學知名的通識課程，完全免費，在 <a href="https://www.edx.org/course/cs50s-introduction-to-computer-science" target="_blank" rel="noopener">edx</a> 或 <a href="https://www.youtube.com/watch?v=Tpl7k8IOT6E" target="_blank" rel="noopener">youtube</a> 或 <a href="https://github.com/athena-xcy/CS50-Study-Group" target="_blank" rel="noopener">CS50-Study-Group github</a> 都可以非常容易地看到。</p><p>這篇文章是我練習寫 Week 1 的作業(因為不知道要放在哪裡，才不會以後找不到，所以就決定放在部落格啦)，歡迎大家有更好的解法可以一起討論唷～</p><p>題目：<a href="https://cs50.harvard.edu/college/2020/fall/labs/1/#:~:text=Lab%201:%20Population%20Growth" target="_blank" rel="noopener">Lab 1: Population Growth</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cs50.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Prompt for start size</span></span><br><span class="line">    <span class="keyword">int</span> start_size;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        start_size = get_int(<span class="string">"Start size: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (start_size &lt; <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prompt for end size</span></span><br><span class="line">    <span class="keyword">int</span> end_size;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        end_size = get_int(<span class="string">"End size: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (end_size &lt; start_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate number of years until we reach threshold</span></span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        start_size = start_size + start_size/<span class="number">3</span> - start_size/<span class="number">4</span>;</span><br><span class="line">        year += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (start_size &lt; end_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print number of years</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Years: %i\n"</span>, year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CS50 </tag>
            
            <tag> Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS50 week 3 筆記</title>
      <link href="/2020/10/10/cs50-week-3-notes/"/>
      <url>/2020/10/10/cs50-week-3-notes/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近跟同事小夥伴相約一起看 CS50 的課程，CS50 (Introduction to Computer Science）是一堂美國哈佛大學知名的通識課程，完全免費，在 <a href="https://www.edx.org/course/cs50s-introduction-to-computer-science" target="_blank" rel="noopener">edx</a> 或 <a href="https://www.youtube.com/watch?v=tk3wiMbQmow" target="_blank" rel="noopener">youtube</a> 或 <a href="https://github.com/athena-xcy/CS50-Study-Group" target="_blank" rel="noopener">CS50-Study-Group github</a> 都可以非常容易地看到。</p><p>這系列的文章會是我的個人筆記，歡迎有興趣的人一定要自己去看看 CS50 的課程歐。</p><p>今天這篇是 CS50 week 3 筆記，想先看之前筆記的人可以點選下面連結：</p><ul><li><a href="/2020/09/12/cs50-week-0-notes">week 0</a></li><li><a href="/2020/09/19/cs50-week-1-notes">week 1</a></li><li><a href="/2020/09/27/cs50-week-2-notes">week 2</a></li></ul><h2 id="Running-Times"><a href="#Running-Times" class="headerlink" title="Running Times"></a>Running Times</h2><h3 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h3><p>用來表示執行所需要最大步驟(n)的最大時間</p><ul><li>O(n^2)</li><li>O(n log n)</li><li>O(n)</li><li>O(log n)</li><li>O(1)</li></ul><h3 id="Omega"><a href="#Omega" class="headerlink" title="Omega"></a>Omega</h3><p>用來表示執行所需要最小步驟(n)的最小時間</p><ul><li>Ω(n^2)</li><li>Ω(n log n)</li><li>Ω(n)</li><li>Ω(log n)</li><li>Ω(1)</li></ul><h3 id="Theta"><a href="#Theta" class="headerlink" title="Theta"></a>Theta</h3><p>當 Big O 和 Omega 相同的時候可以用 Theta 來表示</p><ul><li>Θ(n^2)</li><li>Θ(n log n)</li><li>Θ(n)</li><li>Θ(log n)</li><li>Θ(1)</li></ul><h2 id="Linear-Search"><a href="#Linear-Search" class="headerlink" title="Linear Search"></a>Linear Search</h2><p>講者用好幾個門表示 Array，當我們想要在這個 Array 中找到一個特定數字，我們從第一個門由左到右一個一個地打開，直到找到想要找的數字為止。</p><p>這樣的搜尋方式，如果用 Big O 表示的話就會是 <strong>O(n)</strong>，n 表示這個 Array 的長度，也就是說我們不幸的在最後一道門打開，才找到想要找的數字。<br>如果是用 Omega 來表示的話就會是 <strong>Ω(1)</strong>，因為我們可能很幸運地在第一個門打開，就找到我們要找的數字。</p><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>當門後面的數字已經排序好了，我們就可以用 Binary Search，每次切一半搜尋，看打開的數字是比想要找的數字大還小，決定要繼續往左或右的中間搜尋(其實就是 week 0 的時候提到從電話簿中找電話的二分法)，每次都從中間搜尋直到找到想要找的數字為止。</p><p>這樣的搜尋方式，如果用 Big O 表示的話就會是 <strong>O(log n)</strong>，n 表示這個 Array 的長度，log 則是以 2 為底數，如果有 8 個門，每次切一半，最多要切三次才能找到想要找的數字，即 2^3 = 8，也就是 log 8 = 3，故為 log n。<br>如果是用 Omega 來表示的話就會是 <strong>Ω(1)</strong>，因為我們可能很幸運地在中間的門打開，就找到我們要找的數字。</p><p>Binary Search 比 Linear Search 快得多，當 n 越大的時候會越明顯。</p><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><p>在 c 語言中我們不能直接進行 string 的比較(理由會在下堂課程說明)，而在 string.h 中提供給我們進行 string 比較的 function 叫做 <strong><a href="https://www.programiz.com/c-programming/library-function/string.h/strcmp" target="_blank" rel="noopener">strcmp</a></strong>，如果傳入的兩個 string 相同的話會回傳 0，如果第一個 string 比較大的話會回傳正數，如果比較小的話會回傳負數，其中 string 的大小是針對第一個不同的字母經過 <a href="https://www.asciichart.com" target="_blank" rel="noopener">ASCII</a> 轉換成數字比較後決定。</p><h2 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h2><p>透過以下程式碼，我們可以創造自己的 data type：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> number;</span><br><span class="line">&#125;</span><br><span class="line">person;</span><br></pre></td></tr></table></figure><p>可以用以下方式給值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person people[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">people[<span class="number">0</span>].name = <span class="string">"Cindy"</span>;</span><br><span class="line">people[<span class="number">0</span>].number = <span class="string">"09xx-xxx-xxx"</span>;</span><br></pre></td></tr></table></figure><h2 id="sorting"><a href="#sorting" class="headerlink" title="sorting"></a>sorting</h2><h3 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h3><p>當我們有一串數字需要做排序時，因為電腦只能一個一個的檢查，不像人類可以一眼看出哪個數字最小，所以電腦要從頭到尾一個一個的比較後，挑出最小的數字放到最左邊，並將左邊多出來的數字放到右邊有空缺的位置，接著排除已經排好的數字，繼續從頭到尾掃一次，找出最小的數字，直到排到最後一個數字為止。</p><p>假設總共有 n 個數字需要排序，排序的次數如下：<br><code>n + (n - 1) + (n - 2) + ... + 1</code> 因為每次都會排好一個數字，所以每次遞減 1<br><code>n(n + 1)/2</code><br><code>(n^2+n)/2</code><br><code>n^2/2 + n/2</code><br>當 n 越大的時候，具有影響力的會是 n^2，所以用 Big O 表示的話就會是 <strong>O(n^2)</strong>。<br>如果是用 Omega 來表示的話就會是 <strong>Ω(n^2)</strong>，因為就算已經排序好了我們還是得一個個的檢查。<br>可以用 <strong>Θ(n^2)</strong> 表示。</p><h3 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h3><p>從左到右每次兩兩比較並排序，如此會像泡泡跑到頂端一樣，最大的數字會最先到頂端(右邊)排好，重複進行兩兩比較，直到最後所有的數字都跑到比較中數字的頂端。</p><p>假設總共有 n 個數字需要排序，排序的次數如下：<br><code>(n - 1) * (n - 1)</code> 在 n - 1 次(0 到 n)的循環中重複 n - 1 次(從 0 到 n - 2 的兩兩比較)<br><code>n^2 - 1n - 1n + 1</code><br><code>n^2 - 2n + 1</code><br>當 n 越大的時候，具有影響力的會是 n^2，所以用 Big O 表示的話就會是 <strong>O(n^2)</strong>。<br>如果是用 Omega 來表示的話就會是 <strong>Ω(n)</strong>，因為第一次的兩兩比較發現不需要換任何數字的位置而停止(從 0 到 n - 2 的兩兩比較，實際上是 n - 1，但減 1 可以忽略不計)。</p><h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><p>將數字分成左右各半，分別對左半邊和右半邊進行排序，將排序的兩半合併，合併時每次進行左半和右半的比較，分成一半的時候切到最小單位進行，就可以重複進行合併的比較。</p><p>假設總共有 n 個數字需要排序，排序的次數如下：<br>每次會拿 n 個數字進行合併，因為每次對一半進行排序，所以總共移動 log n 次。<br>所以用 Big O 表示的話就會是 <strong>O(n log n)</strong>。<br>如果是用 Omega 來表示的話就會是 <strong>Ω(n log n)</strong>，因為就算已經排序好了我們還是得一個個的檢查。<br>可以用 <strong>Θ(n log n)</strong> 表示。</p><p>雖然這個排序方法更快，但它需要至少另一個 Array 的空間來暫存合併前的數字，即此演算法會需要兩倍的空間。</p><ul><li>Merge Sort 運用到 Recursion，在函數的定義中使用函數自身的方法(例如：切到最小單位重複進行相同步驟)。</li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這堂課讓我對於各種演算法有了更深的認識，在寫程式時可以思考使用到邏輯的時間複雜度是什麼，以及考慮到是時間比較便宜還是空間比較便宜，選擇更適合當下情境的演算法。</p><ul><li><a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc" target="_blank" rel="noopener">Visualization and Comparison of Sorting Algorithms</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CS50 </tag>
            
            <tag> Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS50 week 2 筆記</title>
      <link href="/2020/09/27/cs50-week-2-notes/"/>
      <url>/2020/09/27/cs50-week-2-notes/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近跟同事小夥伴相約一起看 CS50 的課程，CS50 (Introduction to Computer Science）是一堂美國哈佛大學知名的通識課程，完全免費，在 <a href="https://www.edx.org/course/cs50s-introduction-to-computer-science" target="_blank" rel="noopener">edx</a> 或 <a href="https://www.youtube.com/watch?v=v7Ho89RMRIo&t=851" target="_blank" rel="noopener">youtube</a> 或 <a href="https://github.com/athena-xcy/CS50-Study-Group" target="_blank" rel="noopener">CS50-Study-Group github</a> 都可以非常容易地看到。</p><p>這系列的文章會是我的個人筆記，歡迎有興趣的人一定要自己去看看 CS50 的課程歐。</p><p>今天這篇是 CS50 week 2 筆記，想先看 <a href="/2020/09/12/cs50-week-0-notes">week 0</a> 和 <a href="/2020/09/19/cs50-week-1-notes">week 1</a> 筆記的各位觀眾可以點連結過去看看唷！</p><p>課程的一開始講師開始講解上週我們使用的指令 <code>make</code> …</p><h2 id="make-hello"><a href="#make-hello" class="headerlink" title="make hello"></a>make hello</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此檔案為 hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"hello, world"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上週我們使用 make 指令來做 compiling 的時候，輸入完指令後畫面會出現這些 <code>clang -ggdb3 -O0 -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow    hello.c  -lcrypt -lcs50 -lm -o hello</code>，實際上我們在使用的指令其實是 <code>clang</code> 呢！</p><p>而當我們直接使用 <code>clang hello.c</code> 這個指令時，我們編譯出的可執行檔案叫做 <code>a.out</code>(多年前人類決定的預設名稱)，而如果我們輸入的指令為 <code>clang -o hello hello.c</code> 時 (clang 後面的指令可以稱之為 command line arguments)，這次指令的意思是<strong>編譯 hello.c 這個檔案且 output 的檔案要叫 hello</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此檔案為 hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cs50.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = get_string(<span class="string">"What's your name? "</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"hello, %s\n"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當我們引用了 cs50 的 library 時，我們用同樣的 <code>clang -o hello hello.c</code> 指令是會出現 undefined reference to ‘get_string’ 的錯誤，因為我們沒有告訴電腦我們有使用到 cs50 的 library，這時候指令可以改成 <code>clang -o hello hello.c -lcs50</code>(l 表示 link)，這樣就可以正常運作了，而 <code>make</code> 指令其實就是在幫我們自動做這些事情。</p><h2 id="Compiling"><a href="#Compiling" class="headerlink" title="Compiling"></a>Compiling</h2><p>上週我們簡單的知道從 source code 到 machine code 會經過 compiler，但 compiling 的過程其實可以細分成四個步驟：</p><ol><li><p>Preprocess<br>這個步驟將 header 檔案裡 function 的 prototype(原型) 寫到我們的檔案裡，例如上面的程式碼會變成這樣：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">get_string</span><span class="params">(<span class="built_in">string</span> prompt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="built_in">string</span> format, ...)</span></span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = get_string(<span class="string">"What's your name? "</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"hello, %s\n"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Compiling<br>將 source code(C) 轉變成另一種 source code 叫做 assembly code (對電腦的大腦(CPU)較友善的語言)，看起來像這樣：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">main:                         # @main</span><br><span class="line">    .cfi_startproc</span><br><span class="line"># BB#0:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">.Ltmp0:</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">.Ltmp1:</span><br><span class="line">    .cfi_offset %rbp, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">.Ltmp2:</span><br><span class="line">    .cfi_def_cfa_register %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    xorl    %eax, %eax</span><br><span class="line">    movl    %eax, %edi</span><br><span class="line">    movabsq    $.L.str, %rsi</span><br><span class="line">    movb    $0, %al</span><br><span class="line">    callq    get_string</span><br><span class="line">    movabsq    $.L.str.1, %rdi</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -8(%rbp), %rsi</span><br><span class="line">    movb    $0, %al</span><br><span class="line">    callq    printf</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>Assembling<br>將 assembly code 轉換成最後的 machine code (0 和 1)。</p></li><li><p>Linking<br>將我們寫的程式碼已經轉換的 0 和 1 們，以及有用到的 library 程式碼轉換的 0 和 1 們全部合併再一起。</p></li></ol><h2 id="debugging"><a href="#debugging" class="headerlink" title="debugging"></a>debugging</h2><ul><li>printf：將我們需要的資訊印出來看看問題在哪裡。</li><li><a href="https://github.com/cs50/harvard.cs50.debug" target="_blank" rel="noopener">debug50</a>：CS50 提供給我們的工具，在 <a href="https://ide.cs50.io" target="_blank" rel="noopener">CS50 IDE</a> 中可以直接使用，在執行指令前輸入 debug50，例如 <code>debug50 ./hello</code>，但要先設定  breakpoint，程式才知道要停在哪裡。</li><li>Duck Debugging：說出來就會發現問題，跟桌上的小鴨說說話吧:)</li></ul><h2 id="C-data-types"><a href="#C-data-types" class="headerlink" title="C data types"></a>C data types</h2><p>1 byte(位元組) = 8 bits(位元)</p><ul><li>bool(布林)：1 byte</li><li>char：1 byte</li><li>double：8 bytes</li><li>float：4 bytes</li><li>int：4 bytes</li><li>long：8 bytes</li><li>string：? bytes (依據長度有所不同)</li></ul><p>通常占多少空間依據電腦而有所不同。</p><h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><p>RAM(Random Access Memory)：資料短暫儲存的記憶體(要插電才能運作)，因為還沒有存到永久記憶體中而可能遺失，但速度快。<br>硬碟：資料永久儲存的地方。</p><p>當我們在執行程式的時候，變數會暫存在記憶體中，而佔用的空間可以參考上一段 C data types。</p><h2 id="arrays"><a href="#arrays" class="headerlink" title="arrays"></a>arrays</h2><p>由左至右有序的排列，例如：<code>int scores[3];</code>表示 3 個 integer 的 array，在電腦中慣例是從 0 開始數，所以 3 個數字會是 scores[0]、scores[1]、scores[2]。</p><p>在 function 中可以傳入 array 作為參數，範例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> sum / (<span class="keyword">float</span>) length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="型別轉換"><a href="#型別轉換" class="headerlink" title="型別轉換"></a>型別轉換</h2><p>我們都知道了字母或符號在 <a href="https://www.asciichart.com" target="_blank" rel="noopener">ASCII</a> 都會有對應的數字，所以我們可以直接將 char 或符號轉換成 int，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print 35</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%i\n"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>我們將 char 放在 array 裡實現了 string (雙引號)，所以我們可以 s[0] 取出 string 中的第一個字母，而電腦需要知道在記憶體中這個 string 是在哪裡結束(不會跟記憶體中的其他東西混在一起)，string 會在最後多占一個 byte 存 <code>00000000</code>，或用 <code>\0</code> 表示 byte 中全是 0，又稱為 <code>NUL</code>，告訴電腦這裡是結束的位置，所以我們每次使用 string 都會多佔用一個 byte(00000000)。</p><ul><li>注意：我們在 C 語言可以訪問記憶體中的任何位置。例如我只有存了叫做 HI! 的 string，<code>string s = &quot;HI!&quot;;</code> 卻可以透過 s[3] 得到 0，s[400] 得到記憶體中的某個東西。</li></ul><p>我們可以透過 <code>s[i] != &#39;\0&#39;</code> 來判斷是不是最後一個字母，或著我們可以直接用 <code>string.h</code> 提供給我們的方法 <code>strlen(s)</code> 來知道 string 的長度。</p><h2 id="英文大小寫轉換"><a href="#英文大小寫轉換" class="headerlink" title="英文大小寫轉換"></a>英文大小寫轉換</h2><p>再次觀察 <a href="https://www.asciichart.com" target="_blank" rel="noopener">ASCII</a> 表，我們可以知道 <code>s[i] &gt;= &#39;a&#39; &amp;&amp; s[i] &lt;= &#39;z&#39;</code> 表示是小寫英文字母，而大寫英文和小寫英文都差了 32，所以可以利用這個特性做到大小寫轉換，而 <code>ctype.h</code> 提供給我們 islower function。</p><h2 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command-Line Arguments"></a>Command-Line Arguments</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="built_in">string</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>argc 表示 argument count，使用者輸入的所有字的數量(包含程式指令)。</li><li>argv 表示 argument vector，使用者輸入的所有字(包含程式指令)，以陣列中的 string 來表示。由於 string 本身也是  array，所以我們可以透過 array in array 的關係得到在 argv 中的每一個單字。</li></ul><h3 id="為什麼-main-回傳的是-integer？"><a href="#為什麼-main-回傳的是-integer？" class="headerlink" title="為什麼 main 回傳的是 integer？"></a>為什麼 main 回傳的是 integer？</h3><p>執行指令後會回傳代碼，0 表示正常，1 或其他數字表示錯誤，當我們執行完程式後可利用 <code>echo $?</code> 來確認上一步驟執行的程式最後回傳的值是什麼，以利於發生錯誤時的檢測。</p><h2 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h2><p>當我們在傳紙條的時候不會希望紙條的內容被其他人看懂，這時候我們可能會用類似暗號的方式，而暗號通常會有一個對照表找出暗號要表達的意思，這樣的話只要知道對照表的人就可以知道紙條的內容了，而這時候我們就會想要作加密這件事情，例如我們可能本來想要傳遞的訊息是 <strong>I LOVE YOU</strong> 而我們可以利用 <a href="https://www.asciichart.com" target="_blank" rel="noopener">ASCII</a> 找到對應的數字 <strong>73  76 79 86  89 79 85</strong>，接著將每個值都 +1，內容會變成 <strong>74  77 80 87  90 80 86</strong>，接著再利用 <a href="https://www.asciichart.com" target="_blank" rel="noopener">ASCII</a> 將數字轉換成英文，所以我們最終的結果會變成 <strong>J MPWF ZPV</strong>，其中 key 是 1，plaintext 是 I LOVE YOU，經過 cipher 加密後 ciphertext 為 J MPWF ZPV，如此的話只有知道如何加密且擁有 key 的人才會知道要怎麼解密。</p><p>過程示意如下：</p><p>key       -&gt;<br>plaintext -&gt; <em>cipher</em> -&gt; ciphertext</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這堂課針對前幾堂課的內容做更深入點的說明，讓我們認識 array，也讓我們了解 string 的運作是利用將單字放在 array 裡而達成的，並且了解了字母或符號是如何可以做型別轉換…等等，是內容豐富的一堂課，如果想知道更多的話可以參考<a href="https://cs50.harvard.edu/college/2020/fall/weeks/2" target="_blank" rel="noopener">官網</a>唷！</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS50 </tag>
            
            <tag> Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS50 week 1 筆記</title>
      <link href="/2020/09/19/cs50-week-1-notes/"/>
      <url>/2020/09/19/cs50-week-1-notes/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近跟同事小夥伴相約一起看 CS50 的課程，CS50 (Introduction to Computer Science）是一堂美國哈佛大學知名的通識課程，完全免費，在 <a href="https://www.edx.org/course/cs50s-introduction-to-computer-science" target="_blank" rel="noopener">edx</a> 或 <a href="https://www.youtube.com/watch?v=iRkKEHybf9M&start=490&t=0s" target="_blank" rel="noopener">youtube</a> 或 <a href="https://github.com/athena-xcy/CS50-Study-Group" target="_blank" rel="noopener">CS50-Study-Group github</a> 都可以非常容易地看到。</p><p>這系列的文章會是我的個人筆記，歡迎有興趣的人一定要自己去看看 CS50 的課程歐。</p><p>今天這篇是 CS50 week 1 筆記，想先看 week 0 筆記的各位觀眾可以先點 <a href="/2020/09/12/cs50-week-0-notes">這裡</a> 唷！</p><p>這堂課運用了上一堂課學的 scratch 與 C 語言的對應程式碼，來讓學生更容易進入 C 語言的世界呢！</p><p>一開始講者提醒學生們，寫程式碼除了要 correct 以外，也應該要是 well design &amp; well style。</p><h2 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"hello, world"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們寫了一段程式碼，其中 printf () 中的 f 代表 format，分號告訴電腦結束，但是依照上一堂課學到的，電腦只懂 binary，也就是一切用 1 和 0 表示的世界，所以我們會需要作轉換，讓電腦讀懂我們寫的程式碼，而這轉換的方式我們稱為 compiler。</p><p>過程如下：<br>source code -&gt; <strong>compiler</strong> -&gt; machine code</p><p>指令：</p><ul><li>clang 將 source code 轉成 machine code。</li><li>make + 名稱，這個指令會做 compiler ，並用 make 後面的名稱產生同名可執行的檔案，例如 make hello。</li></ul><p>最後會產生一個 hello 檔案，接著可以用 <code>./hello</code> 執行產生的檔案。</p><h2 id="header-files"><a href="#header-files" class="headerlink" title="header files"></a>header files</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cs50.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>.h 表示 header，<code>#include &lt;stdio.h&gt;</code> 讓我們可以直接使用前人寫好的 printf function。<br><code>#include &lt;cs50.h&gt;</code> 讓我們可以直接使用 cs50 提供給我們的 library。</p><h2 id="錯誤"><a href="#錯誤" class="headerlink" title="錯誤"></a>錯誤</h2><p>當出錯時翻到最上面找錯誤，因為錯誤可能在一開始就發生並且導致後面其他堆疊的錯誤出現，錯誤訊息會告訴我們錯誤發生在第幾行第幾列，另外可以使用 cs50 團隊寫好的 <a href="https://github.com/cs50/help50" target="_blank" rel="noopener">help50</a> 指令獲得更清楚的錯誤訊息，例如執行 <code>help50 make hello</code>。</p><h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p>可以使用 <a href="https://cs50.readthedocs.io/style50/" target="_blank" rel="noopener">style50</a> 做風格檢查，例如執行 <code>style50 hello.c</code>，做風格檢查最重要的目的是要寫出可讀性高的程式碼。</p><h2 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h2><p>註解應該是要講這個程式的目的，而不是講這個程式碼在做什麼，因為這個程式碼在做什麼直接看程式碼就知道了，不需要再寫一次。</p><h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command-Line"></a>Command-Line</h2><p>一些常用的指令：cd, cp, ls, mkdir, mv, rm, rmdir。</p><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>可以參考<a href="https://en.wikipedia.org/wiki/C_data_types" target="_blank" rel="noopener">這裡</a>。</p><ul><li>int: integer，表示只使用 32 位元的整數，超過 40 億的數字將無法計算</li><li>long long: long integer，64 位元的整數。</li><li>float: 浮點數是具有小數點的數字，只使用 32 位元。</li><li>double: 使用 64 位元的 float，讓我們可以做更精確的計算。</li><li>char: 要用單引號不能用雙引號，表示一個字符(byte)。</li></ul><p>如果用 integer 相除的話，會回傳 integer 的結果，可以直接在變數前面用括號重新定義 type。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> z = (<span class="keyword">float</span>) x / (<span class="keyword">float</span>) y</span><br></pre></td></tr></table></figure><h2 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h2><p>將以下這段程式碼放在檔案上面，表示先告訴電腦有這些定義的 function。<br>第一個 void 表示沒有任何返回值，第二個 void 表示不接收任何輸入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">meow</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>第一個 void 表示沒有任何返回值，第二個 int n 表示接收 integer n 這個引數。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">meow</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span> ( <span class="string">"meow\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="float-的限制"><a href="#float-的限制" class="headerlink" title="float 的限制"></a>float 的限制</h2><p>當我們的數字是無限大時，或我們想要顯示小數點後面更多的數字時，電腦會因為記憶體有限的關係，在某位數做四捨五入讓數字變的不是那麼精確。越精確就會需要更大的空間。但我們無法精確的計算無限大的數字，因為我們沒有無限大的空間。</p><h2 id="integer-overflow"><a href="#integer-overflow" class="headerlink" title="integer overflow"></a>integer overflow</h2><p>因為電腦的硬體容量是有限的，假設我們只有 3 位元的容量時，當我們要從二進位的 111 再繼續進一位的時候，就會變成 000，應該是 1000，但因為總共只有 3 位元，所以進一位之後只剩下後面的 3 位元，而出錯了，<a href="https://en.wikipedia.org/wiki/Year_2000_problem" target="_blank" rel="noopener">Y2K bug</a> 就是因為這樣的問題而產生的 bug。而因為目前我們是用 32 位元來計算時間，也就是說最多只能算到 40 億，而未來 2038/1/19 我們將會面臨到一樣的問題。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這堂課大部分的重點都在教 C 語言的語法，筆記就不詳細寫了，有興趣的人也可以直接看官方的<a href="https://cs50.harvard.edu/college/2020/fall/notes/1" target="_blank" rel="noopener">筆記</a>，老實說 C 跟 Ruby 寫起來還真是像，不愧是 CRuby (?)，大概只差在 C 要先做型別的宣告然後多了比較醜的大括號XD，少了人性化的寫法(?)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS50 </tag>
            
            <tag> Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS50 week 0 筆記</title>
      <link href="/2020/09/12/cs50-week-0-notes/"/>
      <url>/2020/09/12/cs50-week-0-notes/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近跟同事小夥伴相約一起看 CS50 的課程，CS50 (Introduction to Computer Science）是一堂美國哈佛大學知名的通識課程，完全免費，在 <a href="https://www.edx.org/course/cs50s-introduction-to-computer-science" target="_blank" rel="noopener">edx</a> 或 <a href="https://www.youtube.com/watch?v=Tpl7k8IOT6E" target="_blank" rel="noopener">youtube</a> 或 <a href="https://github.com/athena-xcy/CS50-Study-Group" target="_blank" rel="noopener">CS50-Study-Group github</a> 都可以非常容易地看到。</p><p>這系列的文章會是我的個人筆記，歡迎有興趣的人一定要自己去看看 CS50 的課程歐。</p><p>開始看影片就被講者激動的演說方式感動到，就像是用盡全力要讓看影片的人聽懂一樣，覺得很棒推薦給大家。</p><h2 id="什麼是-Computer-Science"><a href="#什麼是-Computer-Science" class="headerlink" title="什麼是 Computer Science"></a>什麼是 Computer Science</h2><p>Computer Science is about problem solving，即 CS 就是解決問題的科學，看到這裡不免點頭同意，在工作中我們確實是不停地要去思考如何才能夠解決客戶提出的問題呢！完全不是躲在電腦前面這麼一回事，必須要想辦法去理解客戶需要解決的問題是什麼，並且提出解決問題的方案。所以我們會有個 Input(待解決的問題) 以及 Output(解答)，而這整個過程，就是 Computer Science。</p><h2 id="Binary"><a href="#Binary" class="headerlink" title="Binary"></a>Binary</h2><p>Computer 只有 0 和 1，就像是開燈或關燈，通電或不通電，對電腦來說其實這樣就足夠了，因為他只需要知道有跟沒有，就可以運用 mapping 的方式知道說例如開啟電源是 1 而關閉電源是 0。</p><p>二進位中每個 bits 可以表示 1 和 0，而當我們有更多的 bits 時我們可以數更大的數字，例如二進位的 111(三 bits) 是十進位的 7，1111(四 bits) 是 15。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><a href="https://www.asciichart.com" target="_blank" rel="noopener">ASCII</a> 設計出可以表示字母的數字，例如大寫的 A 是用十進位的 65 表示，或說是二進位的 01000001，電腦會由環境的 context 決定是數字或字母等等。ASCII 一個字(byte) 只有 8 個 bits 故只能排列組合出 256 種不同的字符。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>如果我們將電腦直接理解的低階概念移到了人類更好理解的階層，就是抽象。<br>這讓我想到我們通常覺得比較容易理解的是高階的程式語言，感覺有點相似。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>當人們發現 ASCII 已經不夠用了，開始有了 Unicode 的出現，有 8 bits、16 bits、24 bits，甚至 32 bits，有了如此巨大的空間，所以我們可以有更多更多的特殊符號，而我們常聽到的 UTF-8 就是 Unicode 的一種。</p><p>當我們在電腦畫面上看到 😂，實際上是十進位的 128514，二進位的 000000011111011000000010 呢。</p><h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>RGB(Red、Green、Blue)，當 context 是照片這類跟顏色相關的情況時，由三個 byte 表示分別需要多少 pixel 的紅色、綠色和藍色，而每個 byte 是 8 bits，用十進位表示的話就是每個 byte 有 0-255 可以表示。</p><p>而圖片透過這些顏色(每個點的 RGB)的表示來顯示出來，影片則是透過不同時間顯示不同圖片來表示。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>音樂也可以透過量化的方式來表示，例如某個聲音用什麼數字表示，並用某個數字表示要持續此聲音多久等等。</p><p>而我們人類同意用什麼樣的模式來表示之後，讓電腦如此運作，所以我們有各種不同的檔案型態，但這一切對電腦來說，其實也都只是 1 和 0 的各種變化呢。</p><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p>演算法就是一開始說的 Input(待解決的問題) 以及 Output(解答)，這中間一步步解決問題的過程。</p><p>講者用在電話簿裡找到特定的對象舉例，想到的演算法有三種：</p><ol><li>從頭翻到尾一頁一頁慢慢找。</li><li>每兩頁翻一次，可能會錯過而需要再翻回去找。</li><li>每次對分一半，看要找的對象在前半還是後半(電話簿有按照順序排列)。 =&gt; 這就是常聽到的二分法。</li></ol><p>用二分法可以更有效率的解決問題，因為每次都先解決了一半的問題。<br>這讓我想到以前在寫類似 <a href="https://leetcode.com" target="_blank" rel="noopener">leetcode</a> 的問題的時候都要思考會不會有時間複雜度的問題呢，在思考演算法的時候時間也是要考慮的因素。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>最後講者先用 Pseudocode (用英文直接表示程式邏輯) 帶著大家理解：Function、Condition、Boolean expressions、Loops</p><p>接著用 <a href="https://scratch.mit.edu" target="_blank" rel="noopener">scratch</a> 做為大家的第一個程式語言，並提醒大家拆解分析的重要。</p><p>總之是一堂讓人收穫良多的課程啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CS50 </tag>
            
            <tag> Computer Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code - 函式</title>
      <link href="/2020/08/30/clean-code-function/"/>
      <url>/2020/08/30/clean-code-function/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，相信看過 <a href="/2020/06/06/clean-code">Clean Code - 無瑕的程式碼</a> 這篇文章的朋友們已經知道什麼是 Clean Code 了，之後會陸續針對每個章節做重點整理，以龜速進行中。</p><p><a href="https://amzn.to/3kSY9ug" target="_blank" rel="noopener">無瑕的程式碼－敏捷軟體開發技巧守則 (Clean Code: A Handbook of Agile Software Craftsmanship)</a> 第三章函式，我想就我們寫 Ruby 而言其實可以對應到我們所謂的<strong>方法</strong>。</p><h2 id="簡短！"><a href="#簡短！" class="headerlink" title="簡短！"></a>簡短！</h2><p>關於函式的首要準則，就是要簡短。第二項準則，就是<strong>要比第一項的簡短函式還要更短簡短</strong>。看到書中這段話有相當深刻的感受，當我們在看一段很長的函式(或方法)，其實真的很常會看到不知道在哪裡，懷疑人生。另外想跟大家提一下 <a href="https://thoughtbot.com/blog/sandi-metz-rules-for-developers" target="_blank" rel="noopener">Sandi Metz’ Rules For Developers</a> thoughtbot 的這篇文章，其中第二條規則 <strong>Methods can be no longer than five lines of code.</strong>，跟 clean code 這本書提到的簡短其實都是一樣的道理。希望每個函式(或方法)都一清二楚，透露出本身的意圖。</p><h2 id="只做一件事情"><a href="#只做一件事情" class="headerlink" title="只做一件事情"></a>只做一件事情</h2><p>函式應該做一件事情。他們應該把這件事做好。而且他們應該只做這件事。<br>如果函式只做了函式名稱下<strong>同一層抽象概念</strong>的幾個步驟，那麼，這個函式就算是只做了一件事。觀察函式是否超過<strong>一件事情</strong>的另一種方法，是看你是否能夠從此函式中，提煉出另一個新函式，但此新函式不能只是重新詮釋原函式的實現過程(實作)而已。</p><h3 id="函式的段落"><a href="#函式的段落" class="headerlink" title="函式的段落"></a>函式的段落</h3><p>做一件事的函式沒有辦法被合理的分成不同段落。</p><h2 id="由上而下閱讀程式碼：降層準則"><a href="#由上而下閱讀程式碼：降層準則" class="headerlink" title="由上而下閱讀程式碼：降層準則"></a>由上而下閱讀程式碼：降層準則</h2><p>我們希望程式的閱讀就像是由上而下的敘事。我們希望每個函式的後面都緊接著<strong>下一層次的抽象概念</strong>，如此，我們在閱讀程式可依照看到的一連串函式，對應著抽象層次降層閱讀。這個方法就叫做降層準則。</p><h2 id="Switch-敘述-或-if-else"><a href="#Switch-敘述-或-if-else" class="headerlink" title="Switch 敘述 (或 if/else)"></a>Switch 敘述 (或 if/else)</h2><p>Switch 敘述總是在做 N 件事情，雖然我們無法避開使用 Switch 敘述，但我們能確保讓每個 Switch 敘述都被深埋在較低層次的類別裡，而且他永遠都不會被重複使用。我們可以利用多型(Polymorphism)來達到這樣的目的。</p><p>關於 Ruby 如何利用多型(Polymorphism)來達到這樣的目的，可參考 <a href="https://www.youtube.com/watch?v=mpA2F1In41w&t=1728" target="_blank" rel="noopener">hafentalks #7 - Sandi Metz: “Go Ahead, Make a Mess”</a>。</p><h2 id="使用具描述能力的名稱"><a href="#使用具描述能力的名稱" class="headerlink" title="使用具描述能力的名稱"></a>使用具描述能力的名稱</h2><p>當每個你看到的程式，執行結果都與你想的差不多，你會察覺到你正工作在 Clean Code 之上。<br>別害怕去取較長的名稱，一個較長但具描述性質的名稱，比一個較短但難以理解的名稱還要好。</p><h2 id="函式的參數"><a href="#函式的參數" class="headerlink" title="函式的參數"></a>函式的參數</h2><p>函式的參數數量，最理想的是零個(零參數函式;niladic)，其次是一個(單參數函式;monadic)，再不然就是兩個(雙參數函式;dyadic)。可以的話，盡量避免使用三個參數(三參數函式;triadic)。如果要使用超過三個參數(多參數函式;polyadic)，必須有非常特殊的理由—否則無論如何都不應該如此做。</p><h3 id="單一參數的常見形式"><a href="#單一參數的常見形式" class="headerlink" title="單一參數的常見形式"></a>單一參數的常見形式</h3><ol><li>會問與這個參數有關的問題。</li><li>對這個參數進行某種操作。</li><li>事件。這類的形式比較少見，在這類型中會有輸入型參數，但是不會有輸出型參數。</li></ol><h3 id="旗標-flag-參數"><a href="#旗標-flag-參數" class="headerlink" title="旗標(flag)參數"></a>旗標(flag)參數</h3><p>使用 flag 參數是一種很爛的做法。將一個布林變數傳遞給函式，是一種非常恐怖的習慣。這馬上會使得方法的署名(signature)變得複雜，等同於大聲宣布此函式做了不只一件事。</p><h3 id="物件型態的參數"><a href="#物件型態的參數" class="headerlink" title="物件型態的參數"></a>物件型態的參數</h3><p>當一個函式看起來需要超過兩個或三個的參數時，很可能需要將當中的一些參數包裝在一個類別裡。利用建立物件的方式，減少函式參數的數量，當一堆變數一起被傳遞時，他們是某個概念裡的相似部分，而這個概念應該獲得一個屬於他的名稱。</p><h3 id="動詞和關鍵字"><a href="#動詞和關鍵字" class="headerlink" title="動詞和關鍵字"></a>動詞和關鍵字</h3><p>替函式選一個好名稱，可以產生許多良好的附加價值，例如解釋函式的意圖、解釋函式參數的順序性及意圖。</p><h2 id="要無副作用"><a href="#要無副作用" class="headerlink" title="要無副作用"></a>要無副作用</h2><p>副作用(Side effects)就像是謊言。你的函式保證只做一件事情，卻暗地裡偷偷做了其他事情。有時候會使得同類別的其他變數，產生不可預期的改變。常會導致奇怪的時空耦合(temporal coupling)和順序相依性的問題。如果你必須有一個時空耦合，你應該在函式的名稱中說明清楚。</p><h2 id="指令和查詢的分離"><a href="#指令和查詢的分離" class="headerlink" title="指令和查詢的分離"></a>指令和查詢的分離</h2><p>函式應該要能做某件事，或能回答某個問題，但兩者不該同時發生。</p><h2 id="錯誤處理就是一件事"><a href="#錯誤處理就是一件事" class="headerlink" title="錯誤處理就是一件事"></a>錯誤處理就是一件事</h2><p>當你使用例外處理，而非使用錯誤碼時，新的例外可由例外類別衍生出來，不必被迫重新編譯和重新部署，就可以加入到現有的程式中。</p><h2 id="不要重複自己-DRY-Don’t-Repeat-Yourself"><a href="#不要重複自己-DRY-Don’t-Repeat-Yourself" class="headerlink" title="不要重複自己 DRY(Don’t Repeat Yourself)"></a>不要重複自己 DRY(Don’t Repeat Yourself)</h2><p>重複會讓程式變得擁擠，當演算法某些地方需要改變時，這些修改的地方需要花費 N 倍的工夫，因此也讓遺漏而導致的錯誤，發生的機會變 N 倍。</p><p>重複程式碼也許是軟體裡所有邪惡的根源。許多準則或慣例都是為了控制或移除他而發明的。例如，資料庫的 Codd’s normal forms(柯德正規法)是用來消除資料的重複。又例如，物件導向程式設計是利用將程式碼集中到基本的類別裡，來避免冗餘(redundant)。結構化程式設計、剖面導向程式設計(Aspect Oriented Programming)、元件導向程式設計(Component Oriented Programming)等。</p><h2 id="結構化程式設計"><a href="#結構化程式設計" class="headerlink" title="結構化程式設計"></a>結構化程式設計</h2><p>每個函式，及每個函式裡的區塊，都應該只有一個進入點及一個離開點。要遵守這個準則，代表在一個函式裡，只能有一個 return 敘述，迴圈內不能有任何的 break 或 continue 敘述，而且永遠不能有 goto 敘述。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天的重點整理就到這邊了，還記得我曾經寫過指令和查詢混在一起的方法，被公司 Fred 大大告訴我不應該這樣寫，之後也在 clean code 看到一樣的概念，覺得熟悉，但確實我應該讓方法的命名可以直接看出來是做什麼，如果是要問他是什麼狀態，就不應該邊問邊更改他的狀態啊啊啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Coding </tag>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新手不小心會踩到的坑：我真的複製出物件了嗎？</title>
      <link href="/2020/06/25/ruby-pass-by-reference-and-value/"/>
      <url>/2020/06/25/ruby-pass-by-reference-and-value/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，幾天前公司早上例會的時候，討論了關於 Ruby 的指標，這次的討論讓我明白原來 Ruby 是用 rvalue 來實作，是 pass by value 但如果說超過特定長度的話這個 value 會有一個在 C 語言中實做的參考，讓我想到去年我在公司的<a href="https://5xruby.tw/posts/ruby-pass-by-reference-and-value" target="_blank" rel="noopener">官網</a>也有寫過一篇關於這件事情的文章，所以決定將這篇文章也分享在我自己的部落格裡，以下是原文。</p><hr><p>大家好，今天要來跟大家說一個如果是非本科系的工程師不確定上課有沒有學過，如果是本科系的應該是上課有學過，菜鳥工程師可能會不小心踩到的坑，在開始說明之前先給大家看一段程式碼。</p><p>這是一段很簡單的 Ruby 程式碼，表示調整廣播電台頻道的類別，支援預設電台的功能，也就是說使用者在按下某個按鈕，就可以跳到喜歡的頻道(話說現在年輕人還知道電台嗎？＠＠)。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = presets</span><br><span class="line"></span><br><span class="line">    clean</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span></span></span><br><span class="line">    @presets.delete_if &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007fe7b08ff170 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "88.5"]</span></span><br></pre></td></tr></table></figure><p>大家發現了嗎？ presets 已經被我們改變了，在討論為什麼之前我們先來看看有什麼方式可以傳遞引數！</p><h2 id="傳遞引數的方式"><a href="#傳遞引數的方式" class="headerlink" title="傳遞引數的方式"></a>傳遞引數的方式</h2><ol><li><p>Pass-by-reference：丟到方法裡的引數實際上只是變數的參考(reference)，修改引數就會修改到原始的變數。</p></li><li><p>Pass-by-value：丟到方法裡的引數是變數的值(value)，修改引數不會修改到原始的變數。</p></li></ol><h2 id="Ruby-的引數是如何傳遞？"><a href="#Ruby-的引數是如何傳遞？" class="headerlink" title="Ruby 的引數是如何傳遞？"></a>Ruby 的引數是如何傳遞？</h2><p>參考<a href="https://www.ruby-lang.org/en/documentation/faq/4/" target="_blank" rel="noopener">官網的FAQ</a>：</p><p>在 Ruby 中所有的變數和常數都會指向一個參考物件，除了直接使用會噴 NameError 例外錯誤的未初始化區域變數(沒有參考)，當我們指派一個變數或初始化一個常數，表示我們設定了變數或常數指向的參考物件。</p><p>意思是指派這件事情，實際上並不會產生一個複製的新物件，例如前面範例程式碼中 <code>presets = %w(90.1 106.2 88.5)</code> 表示說 <code>presets</code> 是會指向 <code>%w(90.1 106.2 88.5)</code> 參考物件的變數。</p><p>但 <code>Fixnum</code>, <code>true</code>, <code>nil</code>, 和 <code>false</code> 是例外，他們是 <code>immediate values</code>，變數會保持本身的物件而不是另外指向一個參考物件，這些例外被指派的引數會產生這個類型的複製物件。</p><p>當方法被調用時，引數被指派為參數：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOne</span><span class="params">(n)</span></span></span><br><span class="line">  n += <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">p addOne(a) <span class="comment"># -&gt; 2</span></span><br><span class="line">p a         <span class="comment"># -&gt; 1</span></span><br></pre></td></tr></table></figure><p>當傳遞的是物件的參考時，一個方法是有可能改變傳進來的可變物件(mutable object)：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downer</span><span class="params">(string)</span></span></span><br><span class="line">  string.downcase!</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p a = <span class="string">"HELLO"</span> <span class="comment"># -&gt; "HELLO"</span></span><br><span class="line">p downer(a)   <span class="comment"># -&gt; "hello"</span></span><br><span class="line">p a           <span class="comment"># -&gt; "hello"</span></span><br></pre></td></tr></table></figure><h3 id="小結："><a href="#小結：" class="headerlink" title="小結："></a>小結：</h3><ul><li>Ruby 傳遞引數的方法並沒有相當於其他語言的 pass-by-reference。</li><li>Ruby 是 pass-by-value，但是 values 是 references，Pass by reference value 可能是相對準確的說法。</li></ul><hr><p>回頭看看上面的 code，把 <code>object_id</code> 印出來觀察，presets 改變的原因是因為傳進方法的是可變物件的參考(相同 <code>object_id</code>)，當我們直接改變物件就直接改到了原來的物件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = presets</span><br><span class="line"></span><br><span class="line">    clean</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span></span></span><br><span class="line">    @presets.delete_if &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">    p @presets.object_id <span class="comment"># -&gt; 70140344834080</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p presets.object_id <span class="comment"># -&gt; 70140344834080</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007fe7b08ff170 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "88.5"]</span></span><br></pre></td></tr></table></figure><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>上面的範例，看起來可以改成這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = clean(presets)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(presets)</span></span></span><br><span class="line">    presets.reject &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007f9adfaa2b80 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br></pre></td></tr></table></figure><p>因為 reject 會以傳回一個新的陣列代替更改接收端(presets)，故原本的物件並不會被我們修改到，但這並不一定是個好方法，如果我們不需要在初始化的階段就更改 presets，或是其他實體的方法才需要更改 presets，還是有可能會遇到麻煩。</p><p><strong>所以其實我們真正想要的是，可以用複製物件來代替指向原本物件的參考。</strong></p><h2 id="Ruby-複製物件的方法"><a href="#Ruby-複製物件的方法" class="headerlink" title="Ruby 複製物件的方法"></a>Ruby 複製物件的方法</h2><p>Ruby 有兩種複製物件的方法：<code>dup</code> 和 <code>clone</code>，雖然兩者都會根據接收端建立新物件，但 <code>clone</code> 會保存原始物件的 2 項額外功能，<code>dup</code> 則不會。</p><h3 id="clone-不同於-dup-的-2-項額外功能："><a href="#clone-不同於-dup-的-2-項額外功能：" class="headerlink" title="clone 不同於 dup 的 2 項額外功能："></a><code>clone</code> 不同於 <code>dup</code> 的 2 項額外功能：</h3><ol><li><p><code>clone</code> 會顧及接收端的凍結狀態(frozen status)，如果原始物件已經凍結，那副本也會是凍結的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">object = Object.new</span><br><span class="line">object.freeze</span><br><span class="line">p object.frozen? <span class="comment"># -&gt; true</span></span><br><span class="line">dup_object = object.dup</span><br><span class="line">p dup_object.frozen? <span class="comment"># -&gt; false</span></span><br><span class="line">clone_object = object.clone</span><br><span class="line">p clone_object.frozen? <span class="comment"># -&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p>如果接收端有單例方法，<code>clone</code> 會複製單例類別(singleton class)。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object = Object.new</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object</span>.<span class="title">wow</span>;</span> <span class="symbol">:wow</span> <span class="keyword">end</span></span><br><span class="line">p object.singleton_methods <span class="comment"># -&gt; [:wow]</span></span><br><span class="line">p object.wow <span class="comment"># -&gt; :wow</span></span><br><span class="line">clone_object = object.clone</span><br><span class="line">dup_object = object.dup</span><br><span class="line">p clone_object.wow <span class="comment"># -&gt; :wow</span></span><br><span class="line">p dup_object.wow <span class="comment"># -&gt; undefined method `wow' for #&lt;Object:0x00007f7effa8af40&gt; (NoMethodError)</span></span><br></pre></td></tr></table></figure></li></ol><p>所以當我們想修改物件的時候，大部分會選則用 <code>dup</code> 而不是 <code>clone</code>，因為凍結的物件無法修改或解凍，所以 <code>clone</code> 可能會回傳無法修改的物件。</p><h2 id="修改程式碼"><a href="#修改程式碼" class="headerlink" title="修改程式碼"></a>修改程式碼</h2><p>所以我們現在將程式碼改成這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuner</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(presets)</span></span></span><br><span class="line">    @presets = presets.dup</span><br><span class="line"></span><br><span class="line">    clean</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">clean</span></span></span><br><span class="line">    @presets.delete_if &#123; <span class="params">|preset|</span> preset[-<span class="number">1</span>].to_i.even? &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p presets = <span class="string">%w(90.1 106.2 88.5)</span> <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br><span class="line">p turner = Tuner.new(presets) <span class="comment"># -&gt; &lt;Tuner:0x00007fe7b08ff170 <span class="doctag">@presets</span>=["90.1", "88.5"]&gt;</span></span><br><span class="line">p presets <span class="comment"># -&gt; ["90.1", "106.2", "88.5"]</span></span><br></pre></td></tr></table></figure><p>恭喜！這樣就解決了我們一開始更改到原始物件的問題了！</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>雖然我們已經解決問題了，但要留意 <code>dup</code> 和 <code>clone</code> 只會產生淺層複製(shallow copy)的物件，意思是對於 <code>Array</code> 這類的集合物件，雖然複製了容器，但並未複製容器內的元素，我們可以在不影響原始物件的情況下加入或移除元素，但是如果我們試圖要修改 <code>Array</code> 裡的元素，就會修改到原始元素，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="string">"Polar"</span>]</span><br><span class="line">p dup_array = array.dup &lt;&lt; <span class="string">"Bear"</span> <span class="comment"># -&gt; ["Polar","Bear"]</span></span><br><span class="line">p dup_array.each &#123; <span class="params">|element|</span> element.sub!(<span class="string">"lar"</span>, <span class="string">"oh"</span>) &#125; <span class="comment"># -&gt; ["Pooh", "Bear"]</span></span><br><span class="line">p array <span class="comment"># -&gt; ["Pooh"]</span></span><br></pre></td></tr></table></figure><p>可以看到我們還是修改到原始物件的元素了，編寫自己的類別的時候我們可以複寫 <code>initialize_copy</code> 這個方法來控制複製過逞的深度，如果需要使用既有類別深層副本的物件，就必須自行處理。</p><p>另外有一個方法是可以使用 <a href="https://ruby-doc.org/docs/ruby-doc-bundle/ProgrammingRuby/book/ref_m_marshal.html" target="_blank" rel="noopener">Marshal</a> 類別來序列化，然後再對集合及其元素進行序列化還原：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="string">"Polar"</span>]</span><br><span class="line">p dup_array = Marshal.load(Marshal.dump(array)) &lt;&lt; <span class="string">"Bear"</span> <span class="comment"># -&gt; ["Polar","Bear"]</span></span><br><span class="line">p dup_array.each &#123; <span class="params">|element|</span> element.sub!(<span class="string">"lar"</span>, <span class="string">"oh"</span>) &#125; <span class="comment"># -&gt; ["Pooh", "Bear"]</span></span><br><span class="line">p array <span class="comment"># -&gt; ["Polar"]</span></span><br></pre></td></tr></table></figure><p>使用 <code>Marshal</code> 會有相當的限制，除了時間，他要對物件序列化並還原序列化，還必須考慮記憶體的需求數量。複製的物件將會佔用它自己的記憶體空間，如此一來使得 <code>Marshal::dump</code> 建立序列化位元組資料流，因此假如載入大型物件會使得程式大幅增加記憶體需求。</p><p>另一個問題是 <code>Marshal</code> 並非可以對所有的物件作序列化，例如 IO 類別的實體、單例物件(singleton objects)等，會引發 TypeError 的例外。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>大部分的情況我們使用 <code>dup</code> 就可以解決想要複製物件的問題了，但如果我們可以了解這些限制能讓我們將來在需要做深層副本的時候遠離麻煩。</li><li>Ruby 表現得像為不可變物件傳遞值(pass-by-value)，為可變物件傳遞參考(pass-by-reference)。</li><li><code>dup</code> 和 <code>clone</code> 只會建立淺層副本。</li><li>大多數物件來說，<code>Marshal</code> 能在需要時用來建立深層副本。</li></ul><h3 id="參考：-Effective-Ruby"><a href="#參考：-Effective-Ruby" class="headerlink" title="參考： Effective Ruby"></a>參考： <a href="https://amzn.to/2KzOoVD" target="_blank" rel="noopener">Effective Ruby</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> pass-by-reference </tag>
            
            <tag> pass-by-value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code - 有意義的命名</title>
      <link href="/2020/06/13/clean-code-naming/"/>
      <url>/2020/06/13/clean-code-naming/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，相信看過 <a href="/2020/06/06/clean-code">Clean Code - 無瑕的程式碼</a> 這篇文章的朋友們已經知道什麼是 Clean Code 了，接下來就會需要探討究竟要如何實現？</p><p><a href="https://amzn.to/3kSY9ug" target="_blank" rel="noopener">無瑕的程式碼－敏捷軟體開發技巧守則 (Clean Code: A Handbook of Agile Software Craftsmanship)</a> 第二章有意義的命名，就像我之前說的最簡單最困難，相信已經身為工程師的大家們，寫個 method 是一件相當容易的事情，但寫個好的 method 名稱，似乎就不那麼容易了，本篇文章會針對書中提到的幾個重點做說明並用 Ruby 來做舉例。</p><h2 id="讓名稱代表意圖—-使之名符其實"><a href="#讓名稱代表意圖—-使之名符其實" class="headerlink" title="讓名稱代表意圖—-使之名符其實"></a>讓名稱代表意圖—-使之名符其實</h2><p>變數、方法或類別的名稱，它應該要告訴我們，它為什麼會在這出現、它要做什麼用、該如何使用它。如果一個名稱需要註解的輔助，那麼這個名稱就不具備展現意圖的能力。</p><p>當我們試著說出下面這段程式碼的目的，竟然是一件相當困難的事情，會出現我都看得懂，但不知道他要幹嘛的感覺。我想當我們閱讀程式碼出現這樣的想法的時候，其實就表示說這可能是一段命名不好的程式碼。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_them</span></span></span><br><span class="line">  list1 = []</span><br><span class="line">  the_list.each <span class="keyword">do</span> <span class="params">|x|</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="number">0</span>] == <span class="number">4</span></span><br><span class="line">      list1.push(x)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  list1</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>雖然程式碼很短很簡單，但問題不在於程式碼的簡易度，而是在於程式碼的<strong>隱含性(implicity)</strong>，即程式碼的上下文資訊(context)未能由程式本身明確地展現出來的程度，這邊突然想起<a href="https://www.youtube.com/watch?v=pFDRvya23us" target="_blank" rel="noopener">知識的詛咒</a>，就好像撰寫程式碼的工程師心裡知道一切，但是並沒有把心裡知道的寫出來。</p><p>我們把上面那段程式碼做一些修改：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  flagged_cells = []</span><br><span class="line">  game_board.each <span class="keyword">do</span> <span class="params">|cell|</span></span><br><span class="line">    <span class="keyword">if</span> cell[STATUS_VALUE] == FLAGGED</span><br><span class="line">      flagged_cells.push(cell)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  flagged_cells</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊只是將程式碼的命名做修改，看起來就不太一樣了，比前一個例子清楚一些，那我們再做一些修改：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  flagged_cells = []</span><br><span class="line">  game_board.each <span class="keyword">do</span> <span class="params">|cell|</span></span><br><span class="line">    <span class="keyword">if</span> cell.flagged?</span><br><span class="line">      flagged_cells.push(cell)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  flagged_cells</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  flagged_cells = []</span><br><span class="line">  game_board.each <span class="keyword">do</span> <span class="params">|cell|</span></span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">unless</span> cell.flagged?</span><br><span class="line"></span><br><span class="line">    flagged_cells.push(cell)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  flagged_cells</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>大家發現了嗎？這邊看起來就是有一個遊戲版，然後我們用這個方法取得在遊戲版上被標記的格子。我們只是做重新命名，就看出程式碼的目的了！</p><p>最後還可以改成下面這樣：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flagged_cells</span></span></span><br><span class="line">  game_board.select(&amp;<span class="symbol">:flagged?</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="產生有意義的區別"><a href="#產生有意義的區別" class="headerlink" title="產生有意義的區別"></a>產生有意義的區別</h2><p>如果說我們發現程式碼中出現兩個名稱是看不出區別的，那就不應該同時用這兩個名稱，例如 <code>Info</code> 和 <code>Data</code> 是不可區分的無意義字詞，在沒有特別約定的情況下，<code>money_account</code> 和 <code>money</code>、<code>customer_info</code> 和 <code>customer</code>、<code>account_data</code> 和 <code>account</code>、<code>the_message</code> 和 <code>message</code> 都是沒有區別的！</p><h2 id="使用能唸出來的名稱"><a href="#使用能唸出來的名稱" class="headerlink" title="使用能唸出來的名稱"></a>使用能唸出來的名稱</h2><p>大家可以想像一下，如果工程師們在討論一個念不出來的方法，究竟要怎麼討論？</p><h2 id="使用可被搜尋的名稱"><a href="#使用可被搜尋的名稱" class="headerlink" title="使用可被搜尋的名稱"></a>使用可被搜尋的名稱</h2><p>假設某個數字在程式碼中有特別的意義，<code>WORK_DAY_PER_WEEK = 5</code>，像這樣的寫法會比直接在程式碼中用 5 去做計算來的好，因為如果我們用 <code>WORK_DAY_PER_WEEK</code> 去搜尋整個專案，絕對會比用 5 搜尋來得好！</p><h2 id="類別的命名"><a href="#類別的命名" class="headerlink" title="類別的命名"></a>類別的命名</h2><p>類別和物件應該使用名詞或名詞片語來命名，類別的名稱也不應該是動詞。大家可以參考 <a href="https://railsbook.tw/chapters/08-ruby-basic-4.html" target="_blank" rel="noopener">類別（Class）與模組（Module）</a> 這篇文章，類別其實就像是一個模子，當我們 new 出一個實體（Instance），表示為具有類別上狀態與行為的物件，這就是個名詞無誤。</p><h2 id="方法的命名"><a href="#方法的命名" class="headerlink" title="方法的命名"></a>方法的命名</h2><p>方法應該使用動詞或動詞片語來命名。方法就是個行為，行為是動作，所以應該要是動詞。</p><h2 id="每個概念使用一種字詞"><a href="#每個概念使用一種字詞" class="headerlink" title="每個概念使用一種字詞"></a>每個概念使用一種字詞</h2><p>例如 <code>fetch</code>、<code>retrieve</code>、<code>get</code> 這三個都是取得的意思，應該要統一用一種。</p><h2 id="別說雙關語"><a href="#別說雙關語" class="headerlink" title="別說雙關語"></a>別說雙關語</h2><p>避免使用同一個字詞來表示兩種不同的目的，例如專案中已經大量使用 <code>add</code> 表示相加或相連兩個現有的值，然後形成新的值，而我們今天要撰寫一個新的方法是會將單一參數放入一個集合容器中，那我們可以取名為 add 嗎？如果我們用 <code>add</code> 了是不是就表示整個專案裡的 <code>add</code> 會有兩種意思？這就是一種雙關語的表現，所以我們應該取名為 <code>insert</code> 或 <code>append</code> 之類的。</p><h2 id="使用解決方案領域的命名"><a href="#使用解決方案領域的命名" class="headerlink" title="使用解決方案領域的命名"></a>使用解決方案領域的命名</h2><p>解決方案領域其實就是工程師領域的意思，因為在寫跟在看程式碼的人都是工程師，所以如果可以應該盡量使用工程師一看就懂的字詞，例如 <code>JobQueue</code> 之類的。</p><h2 id="使用問題領域的命名"><a href="#使用問題領域的命名" class="headerlink" title="使用問題領域的命名"></a>使用問題領域的命名</h2><p>問題領域就是這個專案在做什麼領域的事情，例如如果是電商網站那就是電商的領域，如果是遊戲網站就會是遊戲的領域。如果沒有工程師熟悉的字詞可以使用的時候，或某段程式碼與問題領域的概念更接近，我們就會使用該問題領域的術語來命名。</p><h2 id="添加有意義的上下文資訊-Context"><a href="#添加有意義的上下文資訊-Context" class="headerlink" title="添加有意義的上下文資訊 (Context)"></a>添加有意義的上下文資訊 (Context)</h2><p>例如有一個變數 <code>state</code>，如果單看這個變數會看不出這是什麼，如果改成 <code>addr_state</code> 至少可以知道這是地址的州，更好的做法是將零碎的變數給予更大的類別 Address。但記得如果小的名稱就能清楚表達的話，就不需要加入其他 context。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我想從這章節可以學到很多實際上的做法，也會讓我省思過去是不是寫了不好的命名，也確實遇過書中寫到面對不好命名的窘境，雖然說程式碼是要讓電腦去執行的，但其實也是要讓人類去閱讀的，因為撰寫程式碼的也是人類，所以能夠表達清楚，是讓後面接手的人可以更好維護的方法之一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Coding </tag>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby 物件導向設計實踐－敏捷入門</title>
      <link href="/2020/06/09/Practical-Object-Oriented-Design-in-Ruby/"/>
      <url>/2020/06/09/Practical-Object-Oriented-Design-in-Ruby/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，最近在整理 medium 舊的文章 <a href="https://medium.com/@cindyliu923/ruby-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%AF%A6%E8%B8%90%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-e0a357e3fd17" target="_blank" rel="noopener"><strong>Ruby 物件導向設計實踐讀書筆記</strong></a>，想把這篇也放在這裡，但覺得需要重新整理一下，<del>就跟過了一陣子再看我寫的程式碼一樣</del>，所以這篇文章就此誕生？</p><p>首先跟大家說一下，<a href="https://amzn.to/3fmWVGq" target="_blank" rel="noopener">Ruby 物件導向設計實踐－敏捷入門 (Practical Object-Oriented Design in Ruby: An Agile Primer)</a> 是一本書，中文版：<a href="https://tinyurl.com/y3z66m6r" target="_blank" rel="noopener">Ruby 物件導向設計實踐－敏捷入門</a>，作者是 <a href="https://www.sandimetz.com" target="_blank" rel="noopener">Sandi Metz</a> 致力推行物件導向程式設計的實踐，出了兩本書 Practical Object-Oriented Design (POODR) 和 <a href="https://www.sandimetz.com/99bottles" target="_blank" rel="noopener">99 Bottles of OOP</a>，都是關於物件導向設計要如何實踐，而且最近發現 Sandi Metz 有很多場精彩的演講，大家可以去看看：</p><ul><li><a href="https://www.youtube.com/watch?v=v-2yFMzxqwU" target="_blank" rel="noopener">GORUCO 2009 - SOLID Object-Oriented Design by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=8bZh5LMaSmE" target="_blank" rel="noopener">RailsConf 2014 - All the Little Things by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=OMPfEXIlTVE" target="_blank" rel="noopener">RailsConf 2015 - Nothing is Something</a></li><li><a href="https://www.youtube.com/watch?v=PJjHfa5yxlU" target="_blank" rel="noopener">RailsConf 2016 - Get a Whiff of This by Sandi Metz</a></li><li><a href="https://www.youtube.com/watch?v=mpA2F1In41w" target="_blank" rel="noopener">hafentalks #7 - Sandi Metz: “Go Ahead, Make a Mess”</a></li></ul><p><strong>接下來是我在閱讀這本書每一章節的筆記，我另外在下面用註解的方式針對我的筆記做說明</strong></p><blockquote><p>參考程式碼如果是 A 這種沒意義的命名請不要認真覺得要這樣寫唷，只是懶得想例子而已，記得要做有意義的命名。</p></blockquote><h2 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h2><ul><li><a href="#物件導向的設計">物件導向的設計</a></li><li><a href="#設計具有單一職責的類別">設計具有單一職責的類別</a></li><li><a href="#管理依賴關係">管理依賴關係</a></li><li><a href="#建立靈活的介面">建立靈活的介面</a></li><li><a href="#使用鴨子類型技巧降低成本">使用鴨子類型技巧降低成本</a></li><li><a href="#藉由繼承取得行為">藉由繼承取得行為</a></li><li><a href="#使用模組共用角色行為">使用模組共用角色行為</a></li><li><a href="#組合物件">組合物件</a></li><li><a href="#設計節省成本的測試">設計節省成本的測試</a></li></ul><h2 id="物件導向的設計"><a href="#物件導向的設計" class="headerlink" title="物件導向的設計"></a>物件導向的設計</h2><ul><li><p>物件導向設計與依賴關係管理相關</p><ul><li>不受管理的依賴關係很容易造成嚴重破壞，因為物件之間彼此了解太多<blockquote><p>依賴關係其實就是如果某個物件的修改會影響到另一個物件，我們就可以說這兩個物件具有依賴關係</p></blockquote></li></ul></li><li><p>設計的目的是使你日後仍然可以繼續設計</p></li><li><p>設計原則</p><ul><li><p>SOLID</p><ul><li><p>單一職責(Single Responsibility Principle, SRP)</p><blockquote><p>簡單說就是一個物件只做一件事情</p></blockquote></li><li><p>開閉原則(Open-Closed Principle, OCP)</p><blockquote><p>在設計已經完整的前提下只能增加程式碼，不能改既有的程式碼</p></blockquote></li><li><p>里氏代替原則(Liskov Substitution Principle, LSP)</p><blockquote><p>若是使用繼承，子類別實作的行為必須要與父類別或是介面所定義的行為一致，並且子類別要能夠完全取代掉父類別</p></blockquote></li><li><p>介面隔離原則(Interface Segregation Principle, ISP)</p><blockquote><p>No client should be forced to depend on methods it does not use.</p></blockquote></li><li><p>依賴倒置原則(Dependency Inversion Principle, DIP)</p><blockquote><p>簡單講是物件之間的依賴關係的處理，可參考<a href="https://notfalse.net/1/dip" target="_blank" rel="noopener">這篇文章</a>，雖然範例不是 Ruby，但我覺得說明的蠻有趣的，如果說看完文章想轉成 Ruby 的話最後結果類似下面這段程式碼，其中 <code>stuffer</code> 是抽象介面，即實際上並不存在 <code>stuffer</code> 的類別</p></blockquote></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(stuffer)</span></span></span><br><span class="line">    stuffer.new.stuff</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stuff</span></span></span><br><span class="line">    p <span class="string">'咔拉雞腿滿福堡 好棒棒'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spaghetti</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stuff</span></span></span><br><span class="line">    p <span class="string">'大蒜辣椒麵 :D'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">People.new.eat(Hamburger)</span><br><span class="line">People.new.eat(Spaghetti)</span><br></pre></td></tr></table></figure></li><li><p>Don’t Repeat Yourself, DRY</p></li><li><p>Law of Demeter, LoD</p></li></ul></li><li><p>若未進行設計 =&gt; 我可以增加這項功能，但這會把所有東西破壞。</p></li></ul><h2 id="設計具有單一職責的類別"><a href="#設計具有單一職責的類別" class="headerlink" title="設計具有單一職責的類別"></a>設計具有單一職責的類別</h2><ul><li>程式碼應具備的特點(TRUE)<ul><li>透明性(Transparent)-程式碼的修改結果要顯而易見</li><li>合理性(Reasonable)-修改的成本要跟修改後的效益成正比</li><li>可用性(Usable)-既有程式碼在任何時候都要保持可用</li><li>典範性(Examplary)-程式碼本身鼓勵為延續這些特點的修改</li></ul></li><li>判斷方法<ul><li>嘗試用一句話描述類別(Class)，若描述中出現<strong>和</strong>、<strong>或</strong>表示不只做一件事情</li><li>高聚合-這個類別所做的所有事情都與其目標非常相關</li></ul></li><li>依賴<strong>行為</strong>而非資料<blockquote><p>資料庫的相關書籍也有提到說應用程式跟資料應該要分離，在寫程式的時候不應該依賴資料內容才對，否則會有應用程式與資料黏在一起的感覺啊，會進入越來越難寫的窘境</p></blockquote></li><li>只負責單一事物的類別能夠將事物與應用程式的其他部分有所<strong>隔離</strong></li></ul><h2 id="管理依賴關係"><a href="#管理依賴關係" class="headerlink" title="管理依賴關係"></a>管理依賴關係</h2><ul><li>低耦合</li><li>依賴像膠水，類別和接觸到他的事物黏在一起，存在幾滴膠水是有必要的，但如果膠水太多，應用程式會凝結成堅固的一塊</li><li>依賴注入(dependency injection)<blockquote><p>用這樣的方式其實就表示說當 A 和 B 必須具有依賴關係的時候，寧願讓依賴是 B 從外面丟進去 A 裡面，也不要是包在 A 裡面不容易察覺的地方</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @y = y</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * y.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># B 從外面丟進去 A 裡面</span></span><br><span class="line">A.new(x, B.new(...))</span><br></pre></td></tr></table></figure></li><li>隔離依賴<ul><li>隔離實例建立(當無法使用<strong>依賴注入</strong>時)<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一種方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b</span></span></span><br><span class="line">    @b <span class="params">||</span>= B.new(...)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 第二種方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x)</span></span></span><br><span class="line">    @x = x</span><br><span class="line">    @b <span class="params">||</span>= B.new(...)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * @b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>隔離外部訊息<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    x * b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 將外部訊息 b_method 隔離出來(似乎可以用委派)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">b_method</span></span></span><br><span class="line">    b.b_method</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>移除參數順序依賴<ul><li>使用 Hash<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span>, <span class="symbol">:z</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">    @x = args[<span class="symbol">:x</span>]</span><br><span class="line">    @y = args[<span class="symbol">:y</span>]</span><br><span class="line">    @z = args[<span class="symbol">:z</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>明確定義預設值<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">  @x = args[<span class="symbol">:x</span>] <span class="params">||</span> <span class="number">5</span></span><br><span class="line">  @y = args[<span class="symbol">:y</span>] <span class="params">||</span> <span class="number">10</span></span><br><span class="line">  <span class="comment"># 如果是 boolean 下面這樣寫會有問題，全部都變成 true</span></span><br><span class="line">  @z = args[<span class="symbol">:z</span>] <span class="params">||</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 可以改使用 fetch 來寫</span></span><br><span class="line">  @z = args.fetch(<span class="symbol">:z</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 merge</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">  args = defaults.merge(args)</span><br><span class="line">  @x = args[<span class="symbol">:x</span>]</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaults</span></span></span><br><span class="line">  &#123;<span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>隔離多重參數初始化操作<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 當 A 是外部介面的一部分時</span></span><br><span class="line"><span class="comment"># 例如某個框架的東西，對我來說是不能修改的部分</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">SomeFramework</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:x</span>, <span class="symbol">:y</span>, <span class="symbol">:z</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(x, y, z)</span></span></span><br><span class="line">      @x = x</span><br><span class="line">      @y = y</span><br><span class="line">      @z = z</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將外部介面包裝起來</span></span><br><span class="line"><span class="comment"># 為某個特定類別建立實例，可以稱之為 factory，</span></span><br><span class="line"><span class="comment"># 當被迫無法修改外部介面時可以使用的技巧</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">AWrapper</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">a</span><span class="params">(args)</span></span></span><br><span class="line">    SomeFramework::A.new(args[<span class="symbol">:x</span>], args[<span class="symbol">:y</span>], arg[<span class="symbol">:z</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>選擇依賴方向<ul><li>告訴類別他們要依賴那些變化少於他們自身的事物<ul><li>有些類別更容易發生變化</li><li>具體類別比抽象類別更容易發生變化</li><li>修改具有許多依賴關係的類別會造成廣泛的影響<blockquote><p>這邊可以參考上面提到的 SOLID 的 <strong>依賴倒置原則(Dependency Inversion Principle, DIP)</strong></p></blockquote></li></ul></li></ul></li></ul><h2 id="建立靈活的介面"><a href="#建立靈活的介面" class="headerlink" title="建立靈活的介面"></a>建立靈活的介面</h2><ul><li>定義介面<ul><li>公共介面<ul><li>顯露出主要職責</li><li>期望被其他物件呼叫</li><li>不會隨便改變</li><li>其他物件可以放心依賴它</li><li>在測試裡被詳盡記錄</li></ul></li><li>私有介面<ul><li>要處理實作細節</li><li>不希望被傳送到其它物件</li><li>可因任何原因變化</li><li>其他物件不能放心依賴它</li><li>可能不會在測試裡被引用</li></ul></li></ul></li><li>關鍵字(Ruby 裡的方法)<ul><li>public</li><li>protected</li><li>private</li><li>可參考資料：<a href="https://kaochenlong.com/2011/07/26/public-protected-and-private-method-in-ruby" target="_blank" rel="noopener">Public, Protected and Private Method in Ruby</a></li></ul></li><li><strong>詢問傳送方想要什麼</strong>而非<strong>告訴接收者如何表現</strong><ul><li>表示物件之間彼此信任</li></ul></li><li>Law of Demeter, LoD<ul><li>對物件之間的傳遞進行限制：禁止將一則訊息藉由第二個不同的物件轉發給第三個物件，即<strong>只能與你的鄰近對話</strong>或<strong>只能使用一個小圓點</strong></li><li>小心使用委派(delegate) - Ruby 的 <code>delegate.rb</code>、<code>forwardable.rb</code>，Rails 的 <code>delegate</code> 方法</li></ul></li></ul><h2 id="使用鴨子類型技巧降低成本"><a href="#使用鴨子類型技巧降低成本" class="headerlink" title="使用鴨子類型技巧降低成本"></a>使用鴨子類型技巧降低成本</h2><ul><li>鴨子類型(duck typing)<ul><li>多態性(polymorphism):許多不同物件回應相同訊息的能力，duck typing 是實作多態性的方法之一<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(preparers)</span></span></span><br><span class="line">    preparers.each <span class="keyword">do</span> <span class="params">|preparer|</span></span><br><span class="line">      preparer.prepare_something(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 特定的 type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare_something</span><span class="params">(a)</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 特定的 type</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">prepare_something</span><span class="params">(a)</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="藉由繼承取得行為"><a href="#藉由繼承取得行為" class="headerlink" title="藉由繼承取得行為"></a>藉由繼承取得行為</h2><ul><li>classical inheritance<ul><li>繼承的核心是一種用於實作<strong>訊息自動委派</strong>的機制</li></ul></li><li>如果程式碼中的傳送者可以說話，如果說出：<strong>我知道你是誰，因為我知道你會做什麼</strong>，這項知識是一種會增加修改成本的依賴關係</li><li>建立抽象父類別<blockquote><p>這裡會寫說抽象是因為實際上我們不會去 new 一個父類別出來使用，而是會針對不同的情況 new 出不一樣的子類別，所以我們說是將行為提升至抽象，而子類別我們就會說是具體的</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildernB</span> &lt; Father</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>提升抽象行為<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:specific</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">    <span class="keyword">super</span>(args) <span class="comment"># 子類別現在"必須"傳送 super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>從具體分離出抽象<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    <span class="comment"># 本來兩個子類別方法中共用的參數</span></span><br><span class="line">    <span class="comment"># 從具體的子類別中分離出來</span></span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>]</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用範本方法模式(<strong>template method pattern</strong>)<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>] <span class="params">||</span> default_arg1</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>] <span class="params">||</span> default_arg2</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 共同的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg1</span></span></span><br><span class="line">    <span class="string">'10-arg1'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    <span class="string">'23'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildernB</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別的預設值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    <span class="string">'2.1'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>實作所有的範本方法(<strong>template method</strong>)<ul><li>將子類別的方法寫進父類別中，即使是不做事也要實作該方法，讓工程師知道繼承這個類別時一定要實作哪些方法<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 只要在當下稍微用心一點，</span></span><br><span class="line">  <span class="comment"># 建立出在失敗時帶有合理錯誤訊息的程式碼，</span></span><br><span class="line">  <span class="comment"># 就能夠得到永久性的益處</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">default_arg2</span></span></span><br><span class="line">    raise NotImplementedError,</span><br><span class="line">      <span class="string">"This <span class="subst">#&#123;<span class="keyword">self</span><span class="class">.<span class="keyword">class</span>&#125; <span class="title">cannot</span> <span class="title">respond</span> <span class="title">to</span>:"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">  <span class="keyword">end</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="keyword">end</span></span></span></span><br></pre></td></tr></table></figure></li></ul></li><li>父子間的耦合管理<ul><li>緊密耦合的類別會黏再一起，並且可能無法單獨修改<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:specific</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">    <span class="keyword">super</span>(args) <span class="comment"># 子類別現在"必須"傳送 super</span></span><br><span class="line">    <span class="comment"># 這個 super 造成父子之間的耦合</span></span><br><span class="line">    <span class="comment"># 強迫子類別知道如何與其抽象父類別互動</span></span><br><span class="line">    <span class="comment"># 將演算法的知識下放到子類別裡</span></span><br><span class="line">    <span class="comment"># 導致程式碼在多個子類別中重複</span></span><br><span class="line">    <span class="comment"># 並且需要所有子類別在完全相同的地方傳送 super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 父類別有一樣的方法</span></span><br><span class="line">  <span class="comment"># 同上形成耦合</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">other</span></span></span><br><span class="line">    <span class="keyword">super</span>.merge(hash)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用鉤子(hook)訊息解耦<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:share</span>, <span class="symbol">:method_arg1</span>, <span class="symbol">:method_arg2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(**args)</span></span></span><br><span class="line">    @share = arg[<span class="symbol">:share</span>]</span><br><span class="line">    @method_arg1 = arg[<span class="symbol">:method_arg1</span>] <span class="params">||</span> default_arg1</span><br><span class="line">    @method_arg2 = arg[<span class="symbol">:method_arg2</span>] <span class="params">||</span> default_arg2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提供子類別使用</span></span><br><span class="line">    post_initialize(args)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 實作方法，但不做事</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 子類別可選擇性覆蓋這個方法</span></span><br><span class="line">  <span class="comment"># 子類別不再控制初始化</span></span><br><span class="line">  <span class="comment"># 將特殊化提供給更大型的抽象演算法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span></span></span><br><span class="line">    @specific = arg[<span class="symbol">:specific</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">other</span></span></span><br><span class="line">    &#123;<span class="symbol">a:</span> <span class="string">'a'</span>, <span class="symbol">b:</span> <span class="string">'b'</span>&#125;.merge(local_other)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用於子類別覆蓋的 hook</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">local_other</span></span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildrenA</span> &lt; Father</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># 不用強迫子類別知道父類別實作了 other 的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">local_other</span></span></span><br><span class="line">    &#123;<span class="symbol">c:</span> <span class="string">'c'</span>&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>使用 hook 方法可以讓繼承者不用強迫傳送 super，並且還能提供特殊化內容</li></ul></li></ul><h2 id="使用模組共用角色行為"><a href="#使用模組共用角色行為" class="headerlink" title="使用模組共用角色行為"></a>使用模組共用角色行為</h2><ul><li>理解物件所扮演的角色，找出隱藏角色，建立程式碼，以便在多個扮演者之間共用行為，同時要最小化其中所產生的依賴關係</li><li>ruby 的模組(module)<ul><li>撰寫技巧與繼承相似，但模組更在乎的是<strong>像什麼</strong>，而繼承是<strong>是什麼</strong><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/skmetz/poodr2/blob/master/7_10.rb</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Schedulable</span></span></span><br><span class="line">  <span class="keyword">attr_writer</span> <span class="symbol">:schedule</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span></span><br><span class="line">    @schedule <span class="params">||</span>= Schedule.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schedulable?</span><span class="params">(starting, ending)</span></span></span><br><span class="line">    !scheduled?(starting - lead_days, ending)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">scheduled?</span><span class="params">(starting, ending)</span></span></span><br><span class="line">    schedule.scheduled?(<span class="keyword">self</span>, starting, ending)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 包含者可以加以覆蓋</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lead_days</span></span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li><li>找尋方法的順序<ul><li>單例類別(Singleton class 只在這個 instance 所定義的方法)-&gt;模組(extend instance 的 module 所定義的方法)-&gt;類別-&gt;類別包含的模組-&gt;父類別-&gt;父類別包含的模組-&gt;Object …</li><li><a href="https://www.spreered.com/ruby-object-model-1" target="_blank" rel="noopener">Ruby 的繼承鍊 (1) - 如何實踐物件導向</a></li><li><a href="https://www.spreered.com/ruby-object-model-include-prepend-extend" target="_blank" rel="noopener">Ruby 的繼承鍊 (2) - Module 的 include、prepend 和 extend</a></li></ul></li><li><strong>抽象父類別裡的所有程式碼都應該適用於每個繼承他的類別</strong>，父類別不應該包含只適用於部分(而非全部)子類別的程式碼，這項限制也同樣應用在模組上：<strong>模組裡的程式碼必須也能夠一併適用於包含他的所有事物</strong></li><li>里氏代替原則(Liskov Substitution Principle, LSP)：子類型必須能夠代替他們的父類型</li></ul><h2 id="組合物件"><a href="#組合物件" class="headerlink" title="組合物件"></a>組合物件</h2><ul><li>composition<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'forwardable'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parts</span></span></span><br><span class="line">  extend Forwardable</span><br><span class="line">  def_delegators <span class="symbol">:</span>@parts, <span class="symbol">:size</span>, <span class="symbol">:each</span></span><br><span class="line">  <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(parts)</span></span></span><br><span class="line">    @parts = parts</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">    select &#123;<span class="params">|part|</span> part.needs_spare&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Struct 接收的是按順序排列的初始化參數，</span></span><br><span class="line"><span class="comment"># 而 OpenStruct 在初始化時則是接收一個 Hash</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'ostruct'</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">PartsFactory</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">build</span><span class="params">(config, parts_class = Parts)</span></span></span><br><span class="line">    parts_class.new(</span><br><span class="line">      config.collect &#123;<span class="params">|part_config|</span></span><br><span class="line">        create_part(part_config)&#125;)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">create_part</span><span class="params">(part_config)</span></span></span><br><span class="line">    OpenStruct.new(</span><br><span class="line">      <span class="symbol">name:</span>        part_config[<span class="number">0</span>],</span><br><span class="line">      <span class="symbol">description:</span> part_config[<span class="number">1</span>],</span><br><span class="line">      <span class="symbol">needs_spare:</span> part_config.fetch(<span class="number">2</span>, <span class="literal">true</span>))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/skmetz/poodr/blob/master/chapter_8.rb#L422</span></span><br></pre></td></tr></table></figure></li><li>組合允許物件之間的結構獨立性，其代價是需要明確進行訊息委派</li><li>如果問題可以使用組合技巧解決，應該盡可能使用組合，如果無法明確保證繼承是一種更好的解決方案，要用組合，因為組合的依賴關係比繼承少許多</li><li>選擇關係：<ul><li>將繼承用於<strong>是什麼</strong>的關係</li><li>將 duck typing 用於<strong>表現得像什麼</strong>的關係<ul><li>思考角色最明確的方法是從外部，以角色扮演者的持有者作為觀點</li></ul></li><li>將組合用於<strong>含有什麼</strong>的關係</li></ul></li></ul><h2 id="設計節省成本的測試"><a href="#設計節省成本的測試" class="headerlink" title="設計節省成本的測試"></a>設計節省成本的測試</h2><ul><li>測試的意圖<ul><li>找出錯誤</li><li>提供文件<ul><li>抱著假設自己將來會得健忘症一樣來撰寫測試</li></ul></li><li>延後設計決定</li><li>支持抽象<ul><li>除非程式碼有測試，否則會出現一層幾乎無法安全做出任何修改的設計抽象</li></ul></li><li>暴露出設計缺陷<ul><li>如果一項測試需要麻煩的設定，就表示程式碼期望過多的上下文</li><li>如果測試某個物件會將一大堆的其他物件捲進來，這表示程式碼有著大量的依賴關係</li><li>如果測試難以撰寫，那麼其他物件也將會發現這段程式碼難以重複使用</li></ul></li></ul></li><li>測試的內容<ul><li>所有事物只測試一次，並且要在適當的地方進行</li><li>將每個物件當成一個黑盒子</li><li>針對定義在公共介面的訊息撰寫測試</li><li>輸入訊息應該測試其傳回狀態，輸出的命令訊息(command)應該測試是否被傳送(行為測試)，而輸出的查詢訊息(query)則不應該被測試。</li></ul></li><li>測試的方法<ul><li>由外向內的 BDD</li><li>由內向外的 TDD</li></ul></li><li>不要測試沒有依賴關係的輸入訊息，而是刪除它：刪除未使用的程式碼能夠立即節省成本，保留未使用的程式碼比刪除之後再恢復他們所花費的成本更高</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Agile </tag>
            
            <tag> Ruby </tag>
            
            <tag> Design </tag>
            
            <tag> Object-Oriented </tag>
            
            <tag> SOLID </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clean Code - 無瑕的程式碼</title>
      <link href="/2020/06/06/clean-code/"/>
      <url>/2020/06/06/clean-code/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，想跟大家分享最近在閱讀的書：<a href="https://amzn.to/3kSY9ug" target="_blank" rel="noopener">無瑕的程式碼－敏捷軟體開發技巧守則 (Clean Code: A Handbook of Agile Software Craftsmanship)</a>，作者是 <a href="https://github.com/unclebob" target="_blank" rel="noopener">Robert C. Martin (人稱 Uncle Bob)</a>，是一本對程式設計具代表性的書。預計之後會邊看邊將每章閱讀過後的重點及心得整理成一篇文章分享給大家。</p><h2 id="為什麼要閱讀-Clean-Code？"><a href="#為什麼要閱讀-Clean-Code？" class="headerlink" title="為什麼要閱讀 Clean Code？"></a>為什麼要閱讀 Clean Code？</h2><p>想先跟大家分享我想看這本書的原因，主要是因為在工作中曾經被同事唸過我寫了奇怪的程式碼，剛開始工作在開發時我會有 Cindy 的 100 種寫法(這邊的 100 是誇飾)，總之我會寫了之後又改掉、又再重寫、又再改掉、再重寫，始終不清楚怎麼寫才是好的寫法，畢竟要達到功能的實現，本來就有很多的方式，大概就是條條道路通羅馬的概念。對於 Clean Code，我自己目前的想法是<strong>最簡單最困難</strong>，如果說專案的程式碼可以非常清楚的表達目的，即看起來很簡單，讓接手專案的人都可以快速地上手，是我心中的 Clean Code，但其實想要達到如此境界確實是不容易的一件事情，尤其是當專案的商業邏輯相當複雜的時候，一不小心就會被牽著走，所以希望藉由這本書，提升自己的能力，為了成為更好的程式設計師。</p><h2 id="無瑕的程式碼"><a href="#無瑕的程式碼" class="headerlink" title="無瑕的程式碼"></a>無瑕的程式碼</h2><p>Uncle Bob 在書中第一章節首先對無瑕的程式碼進行說明，表示程式碼將一直存在，所以無可避免我們始終會面對現有的程式碼，而如果我們必須面對劣質的程式碼，那麼開發時間的上升絕對是必然的，因為我們必須花更多的時間去理解雜亂的程式碼。作者提出了一個關於<strong>態度</strong>的觀點，表示保護程式碼是我們的工作，即使我們被開發時程推著走的時候也應該要提出程式現況有多少的風險，這些風險是否會讓未來的開發付出更大的代價，表現出我們的專業。</p><h2 id="最根本的難題"><a href="#最根本的難題" class="headerlink" title="最根本的難題"></a>最根本的難題</h2><p>讓開發速度變快的<strong>唯一</strong>方法是隨時隨地都確保程式碼整齊潔淨。這邊我想如果要做到的話，其實邊開發邊檢視是否需要重構是必要的，因為也許在新的需求進來的時候，程式應該要如何設計的面貌會更清晰，所以作者曾經在 <a href="https://www.youtube.com/watch?v=2dKZ-dWaCiU&t=3616" target="_blank" rel="noopener">ITkonekt 2019</a> 的演講說過我們如果可以延遲應該盡量先延遲某些決定。</p><h2 id="什麼是-Clean-Code？"><a href="#什麼是-Clean-Code？" class="headerlink" title="什麼是 Clean Code？"></a>什麼是 Clean Code？</h2><p>這邊作者認為每個人對於 Clean Code 會有不同的看法，所以列了一些他請教不同資深程式設計師的說法，其中 Bjarne Stroustrup (<a href="https://amzn.to/2J4K9QM" target="_blank" rel="noopener">The C++ Programming Language</a> 的作者) 表示 Clean Code 對細節相當在意，如：<a href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" target="_blank" rel="noopener">記憶體流失(memory leak)</a>、<a href="https://zh.wikipedia.org/zh-tw/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener">競爭情況(race condition)</a>、不一致的命名方式(下一篇文章會介紹)……等等。Grady Booch (<a href="https://amzn.to/3nQ0d8r" target="_blank" rel="noopener">Object-Oriented Analysis and Design with Applications</a> 的作者) 指出我們撰寫的程式碼應該說明事實，不該使人臆測。這邊我指出幾個印象深刻的，想看更多的大家可以去買書看看唷。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>作者表示我們可以把此書當作是<strong>整潔程式碼之物件學派</strong>，可以學到如何寫出整潔又專業的程式碼，但不要當作這些絕對是<strong>對的</strong>，還有其他不同學派值得我們學習。</p><p>最後下面兩點指出我們要寫 Clean Code 的原因：</p><ul><li>當我們要撰寫程式碼前，其實花了不少功夫在不斷的了解舊的程式碼。</li><li>你今天寫程式的難易度，取決於周遭程式碼的可讀性高低。</li></ul><p>下一篇會介紹有意義的命名，敬請期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Clean Code </tag>
            
            <tag> Coding </tag>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料庫 Transaction(交易)</title>
      <link href="/2020/05/31/Database-Transaction/"/>
      <url>/2020/05/31/Database-Transaction/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是 Cindy，非資訊科系相關背景的工程師，對於資料庫始終有許多的不理解，今天想跟大家分享我在網路上找到適合非本科系的同學們看的資料，以及分享一些我對於資料庫 <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">Ttansaction</a> 的理解。</p><h2 id="網路上的相關資料"><a href="#網路上的相關資料" class="headerlink" title="網路上的相關資料"></a>網路上的相關資料</h2><ul><li><p><a href="http://debussy.im.nuu.edu.tw/sjchen/DataBaseMan_Final.html" target="_blank" rel="noopener">資料庫系統管理課程</a><br>關於資料庫 Transaction(交易) 可以看 <strong>Course 8. 交易處理</strong> 和 <strong>Course 9. 並行控制與回復</strong>，裡面有 <strong>杰哥數位教室</strong> youtube 課程可以搭配講義學習，雖然 youtube 音質不是很好，但整體看下來對於沒有上過資料庫課程的工程師，我覺得對於觀念的理解會蠻有幫助的。</p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">MySQL 文件</a></p></li><li><p><a href="https://docs.postgresql.tw/tutorial/advanced-features/transactions" target="_blank" rel="noopener">PostgreSQL 文件</a></p></li><li><p><a href="https://docs.postgresql.tw/the-sql-language/concurrency-control/transaction-isolation" target="_blank" rel="noopener">PostgreSQL 文件 - isolation</a><br>MySQL 和 PostgreSQL 算是目前常用到的資料庫系統，如果在實務上有需要了解的時候，直接看文件會最快，因為各個資料庫系統實作的演算法不同。</p></li></ul><h2 id="什麼是-Transaction"><a href="#什麼是-Transaction" class="headerlink" title="什麼是 Transaction"></a>什麼是 Transaction</h2><p>如果有這樣的情境：某個功能需要對資料庫進行操作，且是對一或多筆資料進行操作，如果中間發生失敗，是不會允許有些資料變更成功，有些資料變更失敗的話，就會需要 Transaction。</p><h3 id="MySQL-關於-Transaction-的描述"><a href="#MySQL-關於-Transaction-的描述" class="headerlink" title="MySQL 關於 Transaction 的描述"></a>MySQL 關於 Transaction 的描述</h3><blockquote><p>Transactions are atomic units of work that can be <strong>committed</strong> or <strong>rolled back</strong>. When a transaction makes multiple changes to the database, either all the changes succeed when the transaction is committed, or all the changes are undone when the transaction is rolled back.</p><p>Database transactions, as implemented by InnoDB, have properties that are collectively known by the acronym <strong>ACID</strong>, for atomicity, consistency, isolation, and durability.</p><p>See Also ACID, commit, <strong>isolation level</strong>, <strong>lock</strong>, rollback.</p></blockquote><h3 id="PostgreSQL-關於-Transaction-的描述"><a href="#PostgreSQL-關於-Transaction-的描述" class="headerlink" title="PostgreSQL 關於 Transaction 的描述"></a>PostgreSQL 關於 Transaction 的描述</h3><blockquote><p>Transactions are a fundamental concept of all database systems. The essential point of a transaction is that it bundles multiple steps into a single, <strong>all-or-nothing</strong> operation. The intermediate states between the steps are not visible to other concurrent transactions, and if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all.</p></blockquote><p>由以上內容可以看到關鍵字 <strong>committed</strong> or <strong>rolled back</strong> ，表示的是 Transaction 的兩種情況：</p><ul><li>成功：committed</li><li>失敗：rolled back</li></ul><p>其實也就是 <strong>all-or-nothing</strong> 的表示，要不是全部成功(all)就是全部失敗(nothing)。<br>最常見的例子就是轉帳，假如小明要轉帳給小美，我們不會希望有轉一半的情況發生，例如小明成功扣了轉帳出去的錢，而小美卻沒有得到小明轉進帳戶的錢，所以我們就會需要 Transaction 來幫助我們做到 <strong>all-or-nothing</strong>。<br>=&gt; 詳細參考資料：<a href="http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch09.pdf" target="_blank" rel="noopener">交易管理</a></p><h2 id="Transaction-的四大特性-ACID"><a href="#Transaction-的四大特性-ACID" class="headerlink" title="Transaction 的四大特性 ACID"></a>Transaction 的四大特性 ACID</h2><ul><li>單元性 (<strong>Atomicity</strong>；基元性)：<ul><li>交易是一個不可再分割的完整個體，它不是全部執行，就是全部不執行。</li><li>確保單元性是回復 (<strong>Recovery</strong>) 的責任。</li></ul></li><li>一致性 (<strong>Consistency</strong>)：<ul><li>如果交易是全部執行，能讓資料庫從某個一致狀態，轉變到另一個一致狀態。我們則稱此次交易具有一致性。</li><li>確保一致性通常是 DBMS 程式設計師的責任。</li></ul></li><li>孤立性 (<strong>Isolation</strong>)：<ul><li>某交易執行期間所用的資料或中間結果，不容許其它交易讀取或寫入，直到此交易被確認 (Commit，即：成功結束) 為止。也就是說，它不應被同時執行的其它交易所干擾。</li><li>確保孤立性是並行控制 (<strong>Concurrency Control</strong>) 的責任。可依需求定立不同層級的限制。</li></ul></li><li>永久性 (<strong>Durability</strong>, Permanency)：<ul><li>一旦交易全部執行，且經過確認 (Commit) 後，其對資料庫所做的變更則永遠有效，即使未來系統當機或毀損。</li><li>一般是以備份(Back Up)、硬碟映射(Disk Mirroring)、系統日誌(System Log、System Journal)等數種方式來達成。</li><li>永久性是回復 (<strong>Recovery</strong>) 的責任。</li></ul></li></ul><p>由上面敘述就可以知道，實現 Transaction 最重要的兩件事情就是：</p><ol><li><strong>失敗回復、復原 (Failure Recovery)</strong></li><li><strong>並行控制 (Concurrency Control)</strong><br>=&gt; 詳細參考資料：<a href="http://debussy.im.nuu.edu.tw/sjchen/Database/Final/Ch10.pdf" target="_blank" rel="noopener">並行控制與回復</a></li></ol><h2 id="SQL-標準中定義了四種數據庫的隔離級別"><a href="#SQL-標準中定義了四種數據庫的隔離級別" class="headerlink" title="SQL 標準中定義了四種數據庫的隔離級別"></a>SQL 標準中定義了四種數據庫的隔離級別</h2><p><img src="https://i.imgur.com/JmoBqZz.png" alt=""></p><blockquote><p>圖片來自 <a href="https://docs.postgresql.tw/the-sql-language/concurrency-control/transaction-isolation" target="_blank" rel="noopener">PostgreSQL 文件</a></p><ul><li>RAED UNCOMMITED：使用查詢語句不會加鎖，可能會讀到未提交的資料（Dirty Read）</li><li>READ COMMITED：只對記錄加記錄鎖，而不會在記錄之間加間隙鎖，所以允許新的記錄插入到被鎖定記錄的附近，所以再多次使用查詢語句時，可能得到不同的結果（Non-Repeatable Read）</li><li>REPEATABLE READ：多次讀取同一範圍的數據會返回第一次查詢的快照，不會返回不同的數據行，但是可能發生幻讀（Phantom Read）</li><li>SERIALIZABLE：InnoDB 隱式地將全部的查詢語句加上共享鎖，解決了幻讀的問題</li></ul></blockquote><p>p.s. MySQL 的 InnoDB 預設的是 Repeatable Read<br>p.s. PostgreSQL 預設的是 Read Committed</p><h2 id="其他可參考資料："><a href="#其他可參考資料：" class="headerlink" title="其他可參考資料："></a>其他可參考資料：</h2><ul><li><a href="https://blog.fntsr.tw/articles/904/#fn-904-START%20TRANSACTION" target="_blank" rel="noopener">PostgreSQL 與 MySQL 關於 transaction 的設計理念</a></li><li><a href="https://kkc.github.io/2017/10/08/transaction-note" target="_blank" rel="noopener">Transaction 筆記</a></li><li><a href="https://vladmihalcea.com/a-beginners-guide-to-acid-and-database-transactions" target="_blank" rel="noopener">A beginner’s guide to ACID and database transactions</a></li><li><a href="https://www.guru99.com/dbms-transaction-management.html" target="_blank" rel="noopener">DBMS Transaction Management: ACID Properties, Schedule</a></li><li><a href="https://draveness.me/mysql-transaction" target="_blank" rel="noopener">『浅入深出』MySQL 中事务的实现</a></li><li><a href="http://coding-geek.com/how-databases-work" target="_blank" rel="noopener">How does a relational database work</a></li><li><a href="https://vinta.ws/code/locking-and-mvcc-in-mysql-innodb.html" target="_blank" rel="noopener">Locking and MVCC in MySQL InnoDB 鎖機制與多版本並發控制</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> PostgreSQL </tag>
            
            <tag> Database </tag>
            
            <tag> Transaction </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新部落格開張</title>
      <link href="/2020/05/28/first-post/"/>
      <url>/2020/05/28/first-post/</url>
      
        <content type="html"><![CDATA[<p>大家好，我決定要把讀書的筆記寫在這個部落格了，敬請期待？</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
